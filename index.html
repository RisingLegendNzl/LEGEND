<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Terminal Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0,0,0,0.06);
        }
        .form-input {
            border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;
            font-size: 1rem; width: 100%; transition: border-color 0.3s ease;
        }
        .form-input:focus { outline: none; border-color: #4f46e5; }
        .btn {
            font-weight: 600; padding: 12px 20px; border-radius: 8px;
            transition: all 0.2s ease; border: 2px solid transparent; cursor: pointer;
        }
        .btn:disabled { background-color: #e5e7eb; color: #6b7280; cursor: not-allowed; }
        .btn-primary { background-color: #4f46e5; color: #ffffff; }
        .btn-primary:hover:not(:disabled) { background-color: #4338ca; transform: translateY(-1px); }
        .btn-secondary { background-color: #eef2ff; color: #4f46e5; }
        .btn-secondary:hover:not(:disabled) { background-color: #e0e7ff; }
        .btn-danger { background-color: #fee2e2; color: #dc2626; }
        .btn-danger:hover { background-color: #fecaca; }
        
        .history-list, .analysis-list { max-height: 350px; overflow-y: auto; padding-right: 8px; }
        .history-item {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            padding: 12px 20px; /* Adjusted padding for more space */
            border-radius: 88px;
            position: relative; /* Added for badge positioning */
            flex-wrap: wrap; /* Allow content to wrap if needed */
        }
        .history-item.is-success { background-color: #f0fdf4; border-color: #22c55e; }
        .history-item.is-fail { background-color: #fef2f2; border-color: #ef4444; }

        .state-badge {
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 6px;
            color: white;
            position: absolute;
            top: -10px;
            left: 50%; /* Position its left edge at 50% of parent's width */
            transform: translateX(-50%); /* Shift it back by half its own width to truly center */
            z-index: 10; /* Ensure it's on top of other elements */
            white-space: nowrap;
        }
        /* Dynamic background colors based on prediction type ID */
        .bg-amber-500 { background-color: #f59e0b; } /* Orange/Amber for Minus Group */
        .bg-blue-500 { background-color: #3b82f6; } /* Blue for Result Group */
        .bg-red-500 { background-color: #ef4444; } /* Red for Plus Group */
        .bg-sumMinus { background-color: #8b5cf6; } /* Purple */
        .bg-sumResult { background-color: #10b981; } /* Emerald */
        .bg-sumPlus { background-color: #f43f5e; } /* Rose */

        .status-box {
            width: 24px; height: 24px; border-radius: 6px;
            transition: all 0.2s ease;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
        }
        .status-box svg { width: 16px; height: 16px; stroke-width: 2.5; color: #ffffff; }
        
        .success-box { border: 2px solid #dcfce7; background-color: #f0fdf4; }
        .is-success .success-box { background-color: #22c55e; border-color: #16a34a; }

        .fail-box { border: 2px solid #fee2e2; background-color: #fef2f2; }
        .is-fail .fail-box { background-color: #ef4444; border-color: #dc2626; }

        .delete-btn {
            width: 32px; height: 32px; border-radius: 8px; cursor: pointer;
            transition: all 0.2s ease; flex-shrink: 0; display: flex;
            align-items: center; justify-content: center;
            border: 2px solid #e5e7eb; background-color: #fff;
        }
        .delete-btn svg { color: #9ca3af; width: 20px; height: 20px; stroke-width: 2; }
        .delete-btn:hover { background-color: #f3f4f6; border-color: #d1d5db;}
        
        .swap-btn {
            height: 40px; width: 40px;
            background-color: #fff;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; color: #9ca3af;
        }
        .swap-btn:hover { color: #4f46e5; border-color: #c7d2fe; transform: rotate(180deg); }

        .result-display { border-radius: 12px; background-color: #f8fafc; padding: 16px; }
        
        /* Toggle Switch styles */
        .toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            width: 100%;
            padding: 0.5rem 0;
        }
        .toggle-checkbox {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }
        .toggle-switch {
            width: 52px;
            height: 32px;
            background-color: #e5e7eb;
            border-radius: 9999px;
            position: relative;
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0;
        }
        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 28px;
            height: 28px;
            background-color: white;
            border-radius: 9999px;
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .toggle-checkbox:checked + .toggle-switch {
            background-color: #4f46e5;
        }
        .toggle-checkbox:checked + .toggle-switch .toggle-knob {
            transform: translateX(20px);
        }
        
        /* Strategy Guide Dropdown */
        .strategy-guide-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding-top 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            padding-top: 0;
            padding-bottom: 0;
            border-top: 1px solid transparent;
        }
        .strategy-guide-content.open {
            max-height: 1000px; /* Increased for more content */
            margin-top: 1rem;
            padding-top: 1rem;
            border-color: #e5e7eb;
            overflow-y: auto;
        }
        .strategy-guide-content h4 { font-weight: 600; color: #374151; margin-top: 0.5rem; }
        .strategy-guide-content p { color: #6b7280; font-size: 0.875rem; }

        /* Sliders and Numeric Inputs */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        .slider-group label {
            flex-basis: 120px; /* Fixed width for labels */
            font-size: 0.875rem;
            color: #4b5563;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .slider-group input[type="number"] {
            width: 70px; /* Fixed width for number input */
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
            text-align: center;
        }


        /* Roulette Wheel Styles */
        #rouletteWheelContainer {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }
        #rouletteWheel {
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            background-color: #f8fafc;
        }
        .wheel-number-circle.red { fill: #ef4444; stroke: #b91c1c; }
        .wheel-number-circle.black { fill: #1f2937; stroke: #111827; }
        .wheel-number-circle.green { fill: #22c55e; stroke: #16a34a; }

        .wheel-number-text {
            font-size: 8px; /* Adjusted for better fit */
            font-weight: 600;
            fill: white;
            pointer-events: none; /* Allows click through to circle */
        }

        /* Highlighting for current calculation */
        .wheel-number-circle.highlight-diffMinus { stroke: #f59e0b; stroke-width: 3px; } /* Orange */
        .wheel-number-circle.highlight-diffResult { stroke: #3b82f6; stroke-width: 3px; } /* Blue */
        .wheel-number-circle.highlight-diffPlus { stroke: #ef4444; stroke-width: 3px; } /* Red */
        .wheel-number-circle.highlight-sumMinus { stroke: #8b5cf6; stroke-width: 3px; } /* Purple */
        .wheel-number-circle.highlight-sumResult { stroke: #10b981; stroke-width: 3px; } /* Emerald */
        .wheel-number-circle.highlight-sumPlus { stroke: #f43f5e; stroke-width: 3px; } /* Rose */
        .wheel-number-circle.highlight-winning { stroke: #10b981; stroke-width: 4px; } /* Stronger green for winning number */

        .roulette-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #4b5563;
        }
        .roulette-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .bg-roulette-red { background-color: #ef4444; }
        .bg-roulette-black { background-color: #1f2937; }
        .bg-roulette-green { background-color: #22c55e; }
        .bg-highlight-diffMinus { background-color: #f59e0b; }
        .bg-highlight-diffResult { background-color: #3b82f6; }
        .bg-highlight-diffPlus { background-color: #ef4444; }
        .bg-highlight-sumMinus { background-color: #8b5cf6; }
        .bg-highlight-sumResult { background-color: #10b981; }
        .bg-highlight-sumPlus { background-color: #f43f5e; }
        .text-pink-400 { color: #f472b6; } /* Light pink for distance numbers */

        /* Added text color classes for specific groups */
        .text-purple-700 { color: #7e22ce; } /* For base number highlight */

        /* Pattern Alert styles */
        .pattern-alert {
            background-color: #eef2ff;
            border: 2px solid #c7d2fe;
            color: #4338ca;
            border-radius: 8px;
            padding: 12px;
            margin-top: 1rem;
            font-size: 0.875rem;
            text-align: center;
            font-weight: 500;
        }

        /* Explainable AI Details Section */
        .ai-details-section {
            background-color: #f0f4f8; /* Light blue-gray background */
            border-top: 1px solid transparent; /* Start with transparent border */
            border-radius: 0 0 8px 8px;
            padding: 0 16px; /* Start with 0 padding-top/bottom */
            margin-top: 0; /* Start with 0 margin-top */
            font-size: 0.8rem;
            color: #4a5568;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            display: block; /* Show when open */ 
            transition: max-height 0.5s ease-out, padding 0.5s ease-out, margin-top 0.5s ease-out, border-top-color 0.5s ease-out, opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        .ai-details-section.open {
            max-height: 500px; /* Adjust as needed for content */
            padding: 12px 16px; /* Apply padding when open */
            margin-top: 8px; /* Apply margin when open */
            border-top-color: #e2e8f0; /* Apply border color when open */
            opacity: 1;
            visibility: visible;
            display: block; /* Show when open */
        }
        .ai-details-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .ai-details-section li {
            margin-bottom: 4px;
        }
        .ai-details-toggle {
            display: block;
            width: fit-content;
            margin-top: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #4f46e5;
            cursor: pointer;
            text-decoration: underline;
            transition: color 0.2s ease;
        }
        .ai-details-toggle:hover {
            color: #4338ca;
        }
    </style>
</head>
<body class="text-gray-800 py-10 px-4">
    <div class="w-full max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        <main class="space-y-8">
            <div class="card p-8 space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl font-bold text-gray-800">Automated Terminal Calculator</h1>
                </div>

                <div class="flex items-center space-x-4">
                    <div class="flex-1 space-y-2">
                        <label for="number1" class="text-sm font-medium text-gray-700">Number to Subtract</label>
                        <input type="number" id="number1" class="form-input">
                    </div>
                    <button id="swapButton" class="swap-btn mt-8 flex-shrink-0" aria-label="Swap numbers">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 12l-4-4m4 4l4-4m6 8v-12m0 12l-4-4m4 4l4-4" />
                        </svg>
                    </button>
                    <div class="flex-1 space-y-2">
                        <label for="number2" class="text-sm font-medium text-gray-700">Subtract From</label>
                        <input type="number" id="number2" class="form-input">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <button id="clearInputsButton" class="w-full btn btn-secondary">Clear Inputs</button>
                    <button id="calculateButton" class="w-full btn btn-primary">Calculate</button>
                </div>
                
                <div id="resultDisplay" class="hidden"></div>
            </div>

            <div class="card p-8 space-y-4" id="historySection">
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-4">
                        <h2 class="text-xl font-bold text-gray-700">History</h2>
                        <div class="text-sm font-medium">
                            <span class="text-green-600 font-semibold">Wins: <span id="winCount">0</span></span> |
                            <span class="text-red-600 font-semibold">Losses: <span id="lossCount">0</span></span>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                         <button id="historyInfoToggle" class="bg-gray-100 text-gray-600 hover:bg-gray-200 px-3 py-1 rounded-md text-sm font-semibold transition-colors duration-200">
                            Info
                            <svg class="inline-block w-4 h-4 ml-1 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                        <div id="historyInfoDropdown" class="absolute right-0 mt-2 w-72 bg-white border border-gray-200 rounded-lg shadow-lg p-4 text-sm text-gray-700 z-10 hidden">
                            <p class="font-semibold mb-2">History Log Insights:</p>
                            <ul class="list-disc pl-4 space-y-1">
                                <li><strong class="text-gray-800">Reco: [Group] (Hit)</strong> <span class="text-xs text-gray-500">(Group Color Badge):</span> Your recommended group was successful.</li>
                                <li><strong class="text-gray-800">Reco: [Group] (Missed), Hit: [Other Group(s)]</strong> <span class="text-xs text-gray-500">(Red Badge):</span> Your recommended group missed, but another group happened to hit.</li>
                                <li><strong class="text-gray-800">Reco: [Group] (Missed)</strong> <span class="text-xs text-gray-500">(Group Color Badge/Red Cross):</span> Your recommended group and all other active groups missed.</li>
                                <li><strong class="text-green-600">Green checkmark:</strong> Overall, at least one active group hit.</li>
                                <li><strong class="text-red-600">Red cross:</strong> Overall, no active group hit.</li>
                            </ul>
                        </div>
                        <button id="clearHistoryButton" class="btn btn-danger text-sm py-2 px-3">Clear History</button>
                    </div>
                </div>
                <ul id="historyList" class="history-list space-y-3"></ul>
            </div>
        </main>
        
        <aside class="space-y-8">
            <div class="card p-8">
                <div id="rouletteWheelSection">
                    <h2 class="text-xl font-bold text-gray-700">Roulette Wheel Visualizer</h2>
                    <div id="rouletteWheelContainer"></div>
                    <div class="mt-4 grid grid-cols-2 gap-2 text-sm" id="rouletteLegend">
                    </div>
                </div>
            </div>
            
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Video Analysis Engine</h2>
                <p class="text-sm text-gray-500">Upload a short video of the spin result to detect the winning number.</p>
                
                <div id="videoUploadContainer" class="mt-2">
                    <input type="file" id="videoUpload" class="hidden" accept="video/*">
                    <label for="videoUpload" id="videoUploadLabel" class="w-full text-center btn btn-secondary cursor-pointer">Upload Spin Video</label>
                </div>

                <div id="videoControlsContainer" class="mt-2 grid grid-cols-2 gap-2 hidden">
                    <button id="clearVideoButton" class="w-full btn btn-danger">Clear Video</button>
                    <button id="analyzeVideoButton" class="w-full btn btn-primary">Analyze Video</button>
                </div>

                <p id="videoStatus" class="text-sm text-center text-gray-600 h-4 mt-2"></p>
                <video id="videoPlayer" class="w-full h-48 object-cover rounded-lg hidden bg-gray-900" controls></video>
                <canvas id="frameCanvas" class="w-full h-48 object-cover rounded-lg hidden mt-2"></canvas>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Global Analysis</h2>
                <p class="text-sm text-gray-500">Recalculate all analysis panels based on the current strategy settings. This is useful for back-testing strategies on the entire loaded history.</p>
                <button id="recalculateAnalysisButton" class="w-full btn btn-secondary mt-2">Recalculate All Analyses</button>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Data Input & Training</h2>
                <p class="text-sm text-gray-500">Paste numbers separated by space, comma, or newline, from newest to oldest.</p>
                <textarea id="historicalNumbersInput" class="form-input" rows="4" placeholder="e.g., 10, 5, 22, ... (10 is newest)"></textarea>
                <div class="mt-2">
                    <input type="file" id="imageUpload" class="hidden" accept="image/*">
                    <label for="imageUpload" id="imageUploadLabel" class="w-full text-center btn btn-secondary cursor-pointer">Upload Image of History</label>
                </div>
                <button id="analyzeHistoricalDataButton" class="w-full btn btn-primary mt-2">Analyze Historical Data & Train AI</button>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Status & Analysis</h2>
                <p class="text-sm text-gray-500">Monitor the AI's current status and performance.</p>
                <p id="historicalAnalysisMessage" class="text-sm text-gray-600 mt-2 text-center"></p>
                <div id="aiModelStatus" class="text-sm text-gray-700 text-center font-medium"></div>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Parameter Optimizer</h2>
                <p class="text-sm text-gray-500">
                    Use a genetic algorithm to evolve the best possible strategy parameters.
                    The AI will run simulations to find the settings that produce the highest win/loss ratio.
                    <strong>This is a computationally intensive process.</strong>
                </p>
            
                <div class="grid grid-cols-2 gap-4">
                    <button id="startOptimizationButton" class="w-full btn btn-primary">Start Optimization</button>
                    <button id="stopOptimizationButton" class="w-full btn btn-danger" disabled>Stop Optimization</button>
                </div>
            
                <div id="optimizationStatus" class="text-center text-sm font-medium text-gray-700 mt-2 h-10">
                    </div>
            
                <div id="optimizationResult" class="hidden mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
                    <h4 class="font-bold text-indigo-800">Optimization Complete!</h4>
                    <p class="text-sm text-indigo-700">Best W/L Ratio Found: <strong id="bestFitnessResult"></strong></p>
                    <pre id="bestParamsResult" class="text-xs bg-white p-2 rounded-md mt-2 overflow-x-auto"></pre>
                    <button id="applyBestParamsButton" class="w-full btn btn-secondary mt-3">Apply These Settings</button>
                </div>
            </div>

            <div class="card p-8">
                <div id="presetStrategyGuideHeader" onclick="toggleGuide('presetStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-gray-700">Strategy Presets</h2>
                    <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                </div>
                <div id="presetStrategyGuideContent" class="strategy-guide-content">
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-bold text-gray-800">Highest Win Rate</h4>
                            <p>Enables `Neighbour Score Weighting` and `Use Proximity Boost` while disabling all others. This mode plays every round and had the highest overall win rate (51.5%) based on simulations.</p>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Balanced & Safe</h4>
                            <p>Enables all strategies in the disciplined 'Strict' mode. This provides a good win rate (48.9%) on the spins it plays by waiting for trend confirmation.</p>
                        </div>
                            <div>
                            <h4 class="font-bold text-gray-800">Aggressive Signals</h4>
                            <p>Enables all strategies and turns on `Less Strict Mode`. This uses the 'safe' logic but is much more likely to find and flag `(High Confidence)` opportunities.</p>
                        </div>
                    </div>
                </div>
                <div class="pt-4 grid grid-cols-1 md:grid-cols-3 gap-2">
                    <button id="setHighestWinRatePreset" class="btn btn-secondary text-sm">Highest Win Rate</button>
                    <button id="setBalancedSafePreset" class="btn btn-secondary text-sm">Balanced & Safe</button>
                    <button id="setAggressiveSignalsPreset" class="btn btn-secondary text-sm">Aggressive</button>
                </div>
            </div>

            <div class="card p-8">
                    <div id="baseStrategyGuideHeader" onclick="toggleGuide('baseStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                        <h2 class="text-xl font-bold text-gray-700">Base Strategies</h2>
                        <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                    </div>
                    <div id="baseStrategyGuideContent" class="strategy-guide-content">
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-bold text-gray-800">Wait for Trend Confirmation</h4>
                                <p>When enabled, the app becomes more cautious. It will only issue a "Play" recommendation if its top-ranked state is the same as the state that won on the previous successful spin. Otherwise, it will advise you to wait for a stronger signal.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Use Neighbour Score Weighting</h4>
                                <p>When enabled, this makes the recommendation smarter. It boosts the score of states whose "hit zones" contain numbers that are currently "hot" in the "Neighbour Analysis" panel.</p>
                            </div>
                                <div>
                                <h4 class="font-bold text-gray-800">Use Proximity Boost</h4>
                                <p>When enabled, this gives a score boost to the state whose hit zone is physically closest on the roulette wheel to the last number spun, based on the theory of wheel "gravity".</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Show Pocket Distance in History</h4>
                                <p>When enabled, each successful history entry will display the shortest "pocket distance" from the winning number to the successful prediction's hit zone.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Prioritize Lowest Pocket Distance</h4>
                                <p>When enabled, the recommendation will prioritize the group(s) whose hit zone is closest (pocket distance 0 or 1) to the last confirmed winning number. This overrides other strategy weightings if a very close distance is found.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Enable Advanced Calculation Methods</h4>
                                <p>When enabled, the app will track and recommend based on additional calculation methods (Sum, Sum +/- 1) alongside the standard Difference-based methods. All active methods will compete for the primary recommendation and have their performance tracked.</p>
                            </div>
                        </div>
                    </div>
                    <div class="pt-2 divide-y divide-gray-200">
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Wait for Trend Confirmation</span>
                            <input type="checkbox" id="trendConfirmationToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Use Neighbour Score Weighting</span>
                            <input type="checkbox" id="weightedZoneToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Use Proximity Boost</span>
                            <input type="checkbox" id="proximityBoostToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Show Pocket Distance</span>
                            <input type="checkbox" id="pocketDistanceToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Prioritize Lowest Pocket Distance</span>
                            <input type="checkbox" id="lowestPocketDistanceToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Enable Advanced Calculations</span>
                            <input type="checkbox" id="advancedCalculationsToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                    </div>
            </div>
                <div class="card p-8">
                    <div id="advancedStrategyGuideHeader" onclick="toggleGuide('advancedStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                        <h2 class="text-xl font-bold text-gray-700">Advanced Strategies</h2>
                        <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                    </div>
                    <div id="advancedStrategyGuideContent" class="strategy-guide-content">
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-bold text-gray-800">Dynamic Best Strategy</h4>
                                <p>When enabled, the app will automatically analyze its recent history to identify which single prediction method is performing the best and advise playing it.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Adaptive Play Signals</h4>
                                <p>Provides more nuanced betting advice ('Strong Play', 'Wait', 'Avoid Now') based on the quality and risk of the current signal.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Table Change Warnings</h4>
                                <p>Provides warnings when a previously strong pattern seems to be breaking, helping you avoid potential losing streaks.</p>
                            </div>
                                <div>
                                <h4 class="font-bold text-gray-800">Due for a Hit (Contrarian)</h4>
                                <p>When enabled, this strategy looks for a state that has been performing well below its historical average and recommends it, betting on a return to the mean.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Neighbour Focus</h4>
                                <p>When enabled, this strategy refines the main recommendation by highlighting the "hottest" numbers from the Neighbour Analysis that fall within the recommended group's hit zone.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Less Strict Mode</h4>
                                <p>When enabled, this relaxes the conditions for a "(High Confidence)" recommendation. It will be shown if the top state has a very high hit rate (over 60%) or a long winning streak (3 or more), removing the need for trend confirmation.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Dynamic Terminal Neighbour Count</h4>
                                <p>When enabled, the "hit zone" for a prediction will dynamically adjust its terminal neighbour count based on whether the winning number is a direct hit or a neighbor. If the winning number is the base number or a direct terminal, the terminal neighbour count will be 0. Otherwise, it will use the standard terminal neighbour count (3 or 1).</p>
                            </div>
                        </div>
                    </div>
                    <div class="pt-2 divide-y divide-gray-200">
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Dynamic Best Strategy</span>
                            <input type="checkbox" id="dynamicStrategyToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Adaptive Play Signals</span>
                            <input type="checkbox" id="adaptivePlayToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Table Change Warnings</span>
                            <input type="checkbox" id="tableChangeWarningsToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Due for a Hit (Contrarian)</span>
                            <input type="checkbox" id="dueForHitToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Neighbour Focus</span>
                            <input type="checkbox" id="neighbourFocusToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Less Strict Mode</span>
                            <input type="checkbox" id="lessStrictModeToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Dynamic Terminal Neighbour Count</span>
                            <input type="checkbox" id="dynamicTerminalNeighbourCountToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                    </div>
            </div>

            <div class="card p-8">
                <div id="advancedSettingsHeader" onclick="toggleGuide('advancedSettingsContent')" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-gray-700">Advanced Settings</h2>
                    <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">Adjust Parameters</button>
                </div>
                <div id="advancedSettingsContent" class="strategy-guide-content space-y-6">
                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Strategy Learning Rates</h3>
                        <div class="space-y-3" id="strategyLearningRatesSliders">
                            </div>
                    </div>

                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Pattern & Trigger Thresholds</h3>
                        <div class="space-y-3" id="patternThresholdsSliders">
                            </div>
                    </div>

                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Adaptive Influence Learning</h3>
                        <div class="space-y-3" id="adaptiveInfluenceSliders">
                            </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4 border-t border-gray-200">
                        <button id="resetParametersButton" class="btn btn-secondary">Reset to Defaults</button>
                        <button id="saveParametersButton" class="btn btn-secondary">Save Parameters to File</button>
                        <input type="file" id="loadParametersInput" class="hidden" accept=".json">
                        <label for="loadParametersInput" id="loadParametersLabel" class="w-full text-center btn btn-secondary cursor-pointer">Load Parameters from File</label>
                    </div>

                    <p id="parameterStatusMessage" class="text-sm text-center text-gray-600 mt-2 h-4"></p>
                </div>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Board State Analysis</h2>
                <div id="boardStateAnalysis" class="space-y-2"></div>
                <p id="boardStateConclusion" class="text-center font-bold pt-2"></p>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Dynamic Strategy Weights</h2>
                <div id="strategyWeightsDisplay" class="space-y-3">
                    </div>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Neighbour Analysis</h2>
                <p class="text-sm text-gray-500">Analysis of neighboring numbers based on successes.</p>
                <ul id="analysisList" class="analysis-list space-y-1"></ul>
            </div>
        </aside>
    </div>

    <script>
// ===============================================
// GLOBAL VARIABLES & CONFIGURATION
// ===============================================
const GOOGLE_API_KEY = "YOUR_API_KEY_HERE";
const DEBUG_MODE = true;

let STRATEGY_CONFIG = {
    learningRate_success: 0.35,
    learningRate_failure: 0.05,
    maxWeight: 6.0,
    minWeight: 0.03,
    decayFactor: 0.88,
    patternMinAttempts: 5,
    patternSuccessThreshold: 68,
    triggerMinAttempts: 5,
    triggerSuccessThreshold: 63,
};

let ADAPTIVE_LEARNING_RATES = {
    SUCCESS: 0.15,
    FAILURE: 0.1,
    MIN_INFLUENCE: 0.2,
    MAX_INFLUENCE: 2.5,
};

const DEFAULT_PARAMETERS = {
    STRATEGY_CONFIG: { learningRate_success: 0.30, learningRate_failure: 0.03, maxWeight: 5.0, minWeight: 0.03, decayFactor: 0.88, patternMinAttempts: 5, patternSuccessThreshold: 68, triggerMinAttempts: 5, triggerSuccessThreshold: 63 },
    ADAPTIVE_LEARNING_RATES: { SUCCESS: 0.15, FAILURE: 0.1, MIN_INFLUENCE: 0.2, MAX_INFLUENCE: 2.5 },
    TOGGLES: { useTrendConfirmation: false, useWeightedZone: true, useProximityBoost: true, usePocketDistance: false, useLowestPocketDistance: false, useAdvancedCalculations: false, useDynamicStrategy: false, useAdaptivePlay: false, useTableChangeWarnings: false, useDueForHit: false, useNeighbourFocus: false, useLessStrict: false, useDynamicTerminalNeighbourCount: false }
};

const TRAINING_MIN_HISTORY = 10;
const AI_SEQUENCE_LENGTH = 5;

let aiWorker, optimizationWorker, bestFoundParams = null;
let history = [], confirmedWinsLog = [], patternMemory = {};
let isAiReady = false;
let strategyStates = {
    weightedZone: { weight: 1.0, name: 'Neighbour Weighting' },
    proximityBoost: { weight: 1.0, name: 'Proximity Boost' }
};
let adaptiveFactorInfluences = { 'Hit Rate': 1.0, 'Streak': 1.0, 'Proximity to Last Spin': 1.0, 'Hot Zone Weighting': 1.0, 'High AI Confidence': 1.0, 'Statistical Trends': 1.0 };
let currentVideoURL = null;

let useTrendConfirmation = DEFAULT_PARAMETERS.TOGGLES.useTrendConfirmation;
let useWeightedZone = DEFAULT_PARAMETERS.TOGGLES.useWeightedZone;
let useProximityBoost = DEFAULT_PARAMETERS.TOGGLES.useProximityBoost;
let usePocketDistance = DEFAULT_PARAMETERS.TOGGLES.usePocketDistance;
let useLowestPocketDistance = DEFAULT_PARAMETERS.TOGGLES.useLowestPocketDistance;
let useAdvancedCalculations = DEFAULT_PARAMETERS.TOGGLES.useAdvancedCalculations;
let useDynamicStrategy = DEFAULT_PARAMETERS.TOGGLES.useDynamicStrategy;
let useAdaptivePlay = DEFAULT_PARAMETERS.TOGGLES.useAdaptivePlay;
let useTableChangeWarnings = DEFAULT_PARAMETERS.TOGGLES.useTableChangeWarnings;
let useDueForHit = DEFAULT_PARAMETERS.TOGGLES.useDueForHit;
let useNeighbourFocus = DEFAULT_PARAMETERS.TOGGLES.useNeighbourFocus;
let useLessStrict = DEFAULT_PARAMETERS.TOGGLES.useLessStrict;
let useDynamicTerminalNeighbourCount = DEFAULT_PARAMETERS.TOGGLES.useDynamicTerminalNeighbourCount;

// ===============================================
// ALL FUNCTION DEFINITIONS
// ===============================================

function toggleGuide(contentId) {
    const content = document.getElementById(contentId);
    if (content) content.classList.toggle('open');
}

function runSimulationOnHistory(spinsToProcess) {
    history = [];
    confirmedWinsLog = [];
    patternMemory = {};
    strategyStates = { weightedZone: { weight: 1.0, name: 'Neighbour Weighting' }, proximityBoost: { weight: 1.0, name: 'Proximity Boost' } };
    adaptiveFactorInfluences = { 'Hit Rate': 1.0, 'Streak': 1.0, 'Proximity to Last Spin': 1.0, 'Hot Zone Weighting': 1.0, 'High AI Confidence': 1.0, 'Statistical Trends': 1.0 };
    const baseTimestamp = Date.now();
    for (let i = 0; i <= spinsToProcess.length - 3; i++) {
        const num1 = spinsToProcess[i], num2 = spinsToProcess[i + 1], winningNumber = spinsToProcess[i + 2];
        const diff = Math.abs(num2 - num1);
        const calcId = baseTimestamp + i;
        const trendStatsAtCalc = calculateTrendStats(history);
        const boardStatsAtCalc = getBoardStateStats(history);
        const neighbourScoresAtCalc = runNeighbourAnalysis(false, history);
        const recommendationAtCalc = getRecommendation(trendStatsAtCalc, boardStatsAtCalc, neighbourScoresAtCalc, diff, num1, num2, false, null, adaptiveFactorInfluences);
        const newHistoryItem = {
            id: calcId, num1, num2, difference: diff, status: 'pending', hitTypes: [], typeSuccessStatus: {},
            confirmedStreak: 0, pocketDistance: null, winningNumber,
            recommendedGroupId: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.type.id : null,
            recommendationDetails: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.details : null
        };
        evaluateCalculationStatus(newHistoryItem, winningNumber);
        history.push(newHistoryItem);
        updateStrategyWeights(newHistoryItem);
        if (newHistoryItem.recommendedGroupId && newHistoryItem.recommendationDetails?.primaryDrivingFactor) {
            const primaryFactor = newHistoryItem.recommendationDetails.primaryDrivingFactor;
            const recommendedHit = newHistoryItem.hitTypes.includes(newHistoryItem.recommendedGroupId);
            if (adaptiveFactorInfluences[primaryFactor] === undefined) adaptiveFactorInfluences[primaryFactor] = 1.0;
            if (recommendedHit) adaptiveFactorInfluences[primaryFactor] = Math.min(ADAPTIVE_LEARNING_RATES.MAX_INFLUENCE, adaptiveFactorInfluences[primaryFactor] + ADAPTIVE_LEARNING_RATES.SUCCESS);
            else adaptiveFactorInfluences[primaryFactor] = Math.max(ADAPTIVE_LEARNING_RATES.MIN_INFLUENCE, adaptiveFactorInfluences[primaryFactor] - ADAPTIVE_LEARNING_RATES.FAILURE);
        }
        if (!confirmedWinsLog.includes(winningNumber)) confirmedWinsLog.push(winningNumber);
        updatePatternMemory();
    }
    labelHistoryFailures(history);
    history.reverse();
    confirmedWinsLog = history.map(item => item.winningNumber).filter(n => n !== null).reverse();
    return history;
}

async function handleHistoricalAnalysis() {
    if (DEBUG_MODE) console.log('Analyze Historical Data button clicked.');
    const dom = { historicalAnalysisMessage: document.getElementById('historicalAnalysisMessage'), historicalNumbersInput: document.getElementById('historicalNumbersInput'), aiModelStatus: document.getElementById('aiModelStatus') };
    dom.historicalAnalysisMessage.textContent = 'Processing historical data...';
    const rawInput = dom.historicalNumbersInput.value;
    if (!rawInput.trim()) { dom.historicalAnalysisMessage.textContent = 'Please paste historical numbers.'; return; }
    const numbers = rawInput.trim().split(/[\s,]+/).filter(Boolean).map(Number);
    if (numbers.length < 3 || numbers.some(isNaN) || numbers.some(n => n < 0 || n > 36)) { dom.historicalAnalysisMessage.textContent = 'Please provide at least 3 valid numbers (0-36).'; return; }
    const historicalSpinsChronological = numbers.slice().reverse();
    history = runSimulationOnHistory(historicalSpinsChronological);
    dom.historicalAnalysisMessage.textContent = `Successfully processed and simulated ${history.length} historical entries.`;
    runAllAnalyses();
    renderHistory();
    drawRouletteWheel();
    saveState();
    const successfulHistoryCount = history.filter(item => item.status === 'success').length;
    if (successfulHistoryCount >= TRAINING_MIN_HISTORY) {
        isAiReady = false;
        dom.aiModelStatus.textContent = 'AI Model: Training...';
        aiWorker.postMessage({ type: 'train', payload: { history: history } });
    } else {
        isAiReady = false;
        dom.aiModelStatus.textContent = `AI Model: Need at least ${TRAINING_MIN_HISTORY} confirmed spins to train. (Current: ${successfulHistoryCount})`;
    }
}

function handleStrategyChange() {
    if (DEBUG_MODE) console.log('Strategy toggle changed. Re-simulating current history.');
    const currentWinningNumbers = history.slice().reverse().map(item => item.winningNumber).filter(n => n !== null);
    if (currentWinningNumbers.length < 3) { runAllAnalyses(); renderHistory(); return; }
    history = runSimulationOnHistory(currentWinningNumbers);
    runAllAnalyses();
    renderHistory();
    saveState();
}

// ... (And so on for all 28 helper functions: getNeighbours, getHitZone, etc.) ...
// Helper getters to manage scope issues.
function getFullPredictionTypes() {
    return [
        { id: 'diffMinus', label: 'Minus', displayLabel: 'Minus Group', colorClass: 'bg-amber-500', textColor: '#d97706', calculateBase: (n1, n2) => Math.abs(n2 - n1) - 1 },
        { id: 'diffResult', label: 'Result', displayLabel: 'Result Group', colorClass: 'bg-blue-500', textColor: '#2563eb', calculateBase: (n1, n2) => Math.abs(n2 - n1) },
        { id: 'diffPlus', label: 'Plus', displayLabel: 'Plus Group', colorClass: 'bg-red-500', textColor: '#dc2626', calculateBase: (n1, n2) => Math.abs(n2 - n1) + 1 },
        { id: 'sumMinus', label: 'Sum (-1)', displayLabel: '+ and -1', colorClass: 'bg-sumMinus', textColor: '#8b5cf6', calculateBase: (n1, n2) => (n1 + n2) - 1 },
        { id: 'sumResult', label: 'Sum Result', displayLabel: '+', colorClass: 'bg-sumResult', textColor: '#10b981', calculateBase: (n1, n2) => (n1 + n2) },
        { id: 'sumPlus', label: 'Sum (+1)', displayLabel: '+ and +1', colorClass: 'bg-sumPlus', textColor: '#f43f5e', calculateBase: (n1, n2) => (n1 + n2) + 1 }
    ];
}

function getActivePredictionTypes() {
    const allTypes = getFullPredictionTypes();
    if (useAdvancedCalculations) return allTypes;
    return allTypes.filter(type => type.id.startsWith('diff'));
}

function getNeighbours(number, count) {
    const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];
    const index = rouletteWheel.indexOf(number);
    if (index === -1) return [];
    const neighbours = new Set();
    const wheelSize = rouletteWheel.length;
    for (let i = 1; i <= count; i++) {
        neighbours.add(rouletteWheel[(index - i + wheelSize) % wheelSize]);
        neighbours.add(rouletteWheel[(index + i) % wheelSize]);
    }
    return Array.from(neighbours);
}

function getHitZone(baseNumber, terminals, winningNumber = null) {
    const terminalMapping = {
        0: [4, 6], 1: [8], 2: [7, 9], 3: [8], 4: [11], 5: [12, 10], 6: [11], 7: [14, 2],
        8: [15, 13, 3, 1], 9: [14, 2], 10: [17, 5], 11: [18, 16, 6, 4], 12: [17, 5],
        13: [20, 23], 14: [9, 21, 7, 19], 15: [8, 20], 16: [11], 17: [12, 24, 10, 22],
        18: [11, 23], 19: [14, 26], 20: [13, 25, 15, 27], 21: [14, 26], 22: [17, 29],
        23: [18, 30, 16, 28], 24: [17, 29], 25: [20, 32], 26: [19, 31, 33, 21],
        27: [20, 32], 28: [23, 35], 29: [22, 34, 24, 36], 30: [23, 35], 31: [26],
        32: [25, 27], 33: [26], 34: [29], 35: [28, 30], 36: [29]
    };
    if (baseNumber < 0 || baseNumber > 36) return [];
    const hitZone = new Set([baseNumber]);
    const numTerminals = terminals ? terminals.length : 0;
    let baseNeighbourCount = (numTerminals === 1) ? 3 : (numTerminals >= 2) ? 1 : 0;
    if (baseNeighbourCount > 0) getNeighbours(baseNumber, baseNeighbourCount).forEach(n => hitZone.add(n));
    let terminalNeighbourCount;
    if (useDynamicTerminalNeighbourCount && winningNumber !== null) {
        if (baseNumber === winningNumber || (terminals && terminals.includes(winningNumber))) terminalNeighbourCount = 0;
        else terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
    } else {
        terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
    }
    if (terminals && terminals.length > 0) {
        terminals.forEach(t => {
            hitZone.add(t);
            if (terminalNeighbourCount > 0) getNeighbours(t, terminalNeighbourCount).forEach(n => hitZone.add(n));
        });
    }
    return Array.from(hitZone);
}

function getRouletteNumberColor(number) {
    if (number === 0) return 'green';
    const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
    if (redNumbers.includes(number)) return 'red';
    return 'black';
}

function drawRouletteWheel(currentDiff = null, lastWinningNumber = null) {
    const container = document.getElementById('rouletteWheelContainer');
    if (!container) return;
    container.innerHTML = '';
    const svgWidth = container.clientWidth || 300;
    const svgHeight = svgWidth;
    const radius = (svgWidth / 2) * 0.8;
    const centerX = svgWidth / 2;
    const centerY = svgHeight / 2;
    const numberRadius = 15;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("id", "rouletteWheel");
    svg.setAttribute("width", svgWidth);
    svg.setAttribute("height", svgHeight);
    svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
    const outerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    outerCircle.setAttribute("cx", centerX);
    outerCircle.setAttribute("cy", centerY);
    outerCircle.setAttribute("r", radius + numberRadius + 5);
    outerCircle.setAttribute("fill", "none");
    outerCircle.setAttribute("stroke", "#e2e8f0");
    outerCircle.setAttribute("stroke-width", "2");
    svg.appendChild(outerCircle);
    const highlightedNumbers = new Set();
    const hitZoneClasses = {};
    if (currentDiff !== null && !isNaN(currentDiff)) {
        const num1 = parseInt(document.getElementById('number1').value, 10);
        const num2 = parseInt(document.getElementById('number2').value, 10);
        const activeTypes = getActivePredictionTypes();
        const allTypes = getFullPredictionTypes();
        activeTypes.forEach(type => {
            const def = allTypes.find(t => t.id === type.id);
            if (!def) return;
            const baseNum = def.calculateBase(num1, num2);
            if (baseNum < 0 || baseNum > 36) return;
            const terminals = terminalMapping?.[baseNum] || [];
            const hitZone = getHitZone(baseNum, terminals, lastWinningNumber);
            hitZone.forEach(num => {
                highlightedNumbers.add(num);
                if (!hitZoneClasses[num]) hitZoneClasses[num] = `highlight-${type.id}`;
            });
        });
    }
    const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];
    rouletteWheel.forEach((number, index) => {
        const angle = (index / rouletteWheel.length) * 2 * Math.PI - (Math.PI / 2);
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        const numberColor = getRouletteNumberColor(number);
        let strokeClass = '';
        if (lastWinningNumber !== null && number === lastWinningNumber) strokeClass = 'highlight-winning';
        else if (highlightedNumbers.has(number)) strokeClass = hitZoneClasses[number];
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", numberRadius);
        circle.setAttribute("class", `wheel-number-circle ${numberColor} ${strokeClass}`);
        svg.appendChild(circle);
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", x);
        text.setAttribute("y", y + 3);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("class", "wheel-number-text");
        text.textContent = number;
        svg.appendChild(text);
    });
    container.appendChild(svg);
}

function calculatePocketDistance(num1, num2) {
    const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];
    const index1 = rouletteWheel.indexOf(num1);
    const index2 = rouletteWheel.indexOf(num2);
    if (index1 === -1 || index2 === -1) return Infinity;
    const directDistance = Math.abs(index1 - index2);
    const wrapAroundDistance = rouletteWheel.length - directDistance;
    return Math.min(directDistance, wrapAroundDistance);
}

function updateWinLossCounter() {
    let wins = 0, losses = 0;
    history.forEach(item => {
        if (item.recommendedGroupId) {
            if (item.hitTypes && item.hitTypes.includes(item.recommendedGroupId)) wins++;
            else if (item.winningNumber !== null) losses++;
        }
    });
    document.getElementById('winCount').textContent = wins;
    document.getElementById('lossCount').textContent = losses;
}

function renderHistory() {
    updateWinLossCounter();
    const historyList = document.getElementById('historyList');
    historyList.innerHTML = `<li class="text-center text-gray-500 py-4">No calculations yet.</li>`;
    if (history.length === 0) return;
    historyList.innerHTML = '';
    const allTypes = getFullPredictionTypes();
    history.slice().sort((a, b) => b.id - a.id).forEach(item => {
        const li = document.createElement('li');
        li.className = 'history-item relative';
        if (item.status === 'success') li.classList.add('is-success');
        if (item.status === 'fail') li.classList.add('is-fail');
        let stateBadgeContent, stateBadgeClass = 'bg-gray-400';
        if (item.status === 'pending') stateBadgeContent = 'Pending';
        else if (item.recommendedGroupId !== null) {
            const recommendedType = allTypes.find(type => type.id === item.recommendedGroupId);
            const recommendedLabel = recommendedType?.displayLabel || 'Unknown Group';
            const recommendedColorClass = recommendedType?.colorClass || 'bg-gray-400';
            const recommendedHit = item.hitTypes.includes(item.recommendedGroupId);
            const otherGroupsHit = item.hitTypes.length > 0 && !recommendedHit;
            if (recommendedHit) {
                stateBadgeContent = `Reco: ${recommendedLabel} (Hit)`;
                stateBadgeClass = recommendedColorClass;
            } else if (otherGroupsHit) {
                const otherHitLabels = item.hitTypes.filter(id => id !== item.recommendedGroupId).map(id => allTypes.find(type => type.id === id)?.displayLabel || id);
                stateBadgeContent = `Reco: ${recommendedLabel} (Missed), Hit: ${otherHitLabels.join(' & ')}`;
                stateBadgeClass = 'bg-red-500';
            } else {
                stateBadgeContent = `Reco: ${recommendedLabel} (Missed)`;
                stateBadgeClass = recommendedColorClass;
            }
        } else {
            if (item.status === 'success') stateBadgeContent = 'Success (No Reco)';
            else stateBadgeContent = 'Failed (No Reco)';
            stateBadgeClass = item.status === 'success' ? 'bg-green-600' : 'bg-red-500';
        }
        let pocketDistanceDisplay = (usePocketDistance && item.status === 'success' && item.pocketDistance !== null) ? ` (<span class="text-pink-400">Dist: ${item.pocketDistance}</span>)` : '';
        const showFailIcon = (item.recommendedGroupId && !item.hitTypes.includes(item.recommendedGroupId)) || item.status === 'fail';
        const showSuccessIcon = item.status === 'success' && item.recommendedGroupId && item.hitTypes.includes(item.recommendedGroupId);
        let aiDetailsHtml = '';
        if (item.recommendedGroupId && item.recommendationDetails) {
            const d = item.recommendationDetails;
            aiDetailsHtml = `<div class="ai-details-toggle" data-target="ai-details-${item.id}">Show Details</div><div id="ai-details-${item.id}" class="ai-details-section"><ul>${d.primaryDrivingFactor?`<li><strong>Reason: ${d.primaryDrivingFactor}</strong> (Influence: ${d.adaptiveInfluenceUsed?.toFixed(2)||'1.00'})</li>`:''}<li>Base Score: ${d.baseScore.toFixed(2)}</li>${d.confluenceBonus?`<li>Confluence Bonus: ${d.confluenceBonus.toFixed(2)}x</li>`:''}<li>Hit Rate: ${d.hitRate.toFixed(2)}%</li><li>Avg Trend: ${d.avgTrend.toFixed(1)}</li><li>Proximity: ${d.predictiveDistance!==Infinity?d.predictiveDistance:'N/A'} (Boost: ${d.proximityBoostApplied?'Yes':'No'})</li><li>Neighbour Weighting: ${d.weightedZoneBoostApplied?'Yes':'No'}</li><li>Pattern Boost: ${d.patternBoostApplied?`Yes (${d.patternBoostMultiplier.toFixed(2)}x)`:'No'}</li><li>AI Probability: ${d.mlProbability!==null?(d.mlProbability*100).toFixed(1)+'%':'N/A'} (Boost: ${d.mlBoostApplied?'Yes':'No'})</li><li>AI Low Pocket Boost: ${d.aiLowPocketBoostApplied?'Yes':'No'}</li><li>Final Score: ${d.finalScore.toFixed(2)}</li></ul></div>`;
        }
        li.innerHTML = `${stateBadgeContent?`<div class="state-badge ${stateBadgeClass}">${stateBadgeContent}</div>`:''}<p>${item.num2} - ${item.num1} = <strong class="text-lg">${item.difference}</strong>${pocketDistanceDisplay}</p><div class="flex items-center space-x-2"><div class="status-box fail-box" style="display:${showFailIcon?'flex':'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></div><div class="status-box success-box" style="display:${showSuccessIcon?'flex':'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg></div><button class="delete-btn" data-id="${item.id}" aria-label="Delete item"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m-1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button></div>${aiDetailsHtml}`;
        historyList.appendChild(li);
    });
    document.querySelectorAll('.ai-details-toggle').forEach(toggle => {
        toggle.onclick = () => {
            const target = document.getElementById(toggle.dataset.target);
            if (target) {
                target.classList.toggle('open');
                toggle.textContent = target.classList.contains('open') ? 'Hide Details' : 'Show Details';
            }
        };
    });
}

function renderStrategyWeights() {
    const container = document.getElementById('strategyWeightsDisplay');
    if (!container) return;
    container.innerHTML = '';
    for (const key in strategyStates) {
        const s = strategyStates[key];
        const percent = ((s.weight - STRATEGY_CONFIG.minWeight) / (STRATEGY_CONFIG.maxWeight - STRATEGY_CONFIG.minWeight)) * 100;
        const color = s.weight > 1.0 ? 'bg-green-500' : s.weight < 1.0 ? 'bg-red-500' : 'bg-blue-500';
        container.innerHTML += `<div><div class="flex justify-between items-center mb-1"><span class="font-medium text-sm text-gray-700">${s.name}</span><span class="font-semibold text-sm text-gray-600">${s.weight.toFixed(2)}x</span></div><div class="w-full bg-gray-200 rounded-full h-2.5"><div class="${color} h-2.5 rounded-full" style="width: ${Math.max(0,Math.min(100,percent))}%"></div></div></div>`;
    }
}

function updateStrategyWeights(item) {
    if (!item || item.status === 'pending') return;
    const reco = getRecommendation(calculateTrendStats(), getBoardStateStats(), runNeighbourAnalysis(false), item.difference, item.num1, item.num2, true, null, adaptiveFactorInfluences);
    if (!reco.bestCandidate?.type.id) return;
    const success = item.hitTypes.includes(reco.bestCandidate.type.id);
    if (useWeightedZone) strategyStates.weightedZone.weight = success ? Math.min(STRATEGY_CONFIG.maxWeight, strategyStates.weightedZone.weight + STRATEGY_CONFIG.learningRate_success) : Math.max(STRATEGY_CONFIG.minWeight, strategyStates.weightedZone.weight - STRATEGY_CONFIG.learningRate_failure);
    if (useProximityBoost) strategyStates.proximityBoost.weight = success ? Math.min(STRATEGY_CONFIG.maxWeight, strategyStates.proximityBoost.weight + STRATEGY_CONFIG.learningRate_success) : Math.max(STRATEGY_CONFIG.minWeight, strategyStates.proximityBoost.weight - STRATEGY_CONFIG.learningRate_failure);
    renderStrategyWeights();
}

function updatePatternMemory() {
    const successfulSpins = history.filter(i => i.status === 'success' && i.hitTypes.length > 0).sort((a,b) => a.id - b.id);
    if (successfulSpins.length < 2) return;
    const [prev, last] = successfulSpins.slice(-2);
    if (prev.hitTypes.length === 1 && last.hitTypes.length === 1 && prev.winningNumber !== null) {
        const triggerType = prev.hitTypes[0], triggerNum = prev.winningNumber, resultType = last.hitTypes[0];
        const typeKey = `trigger-type-${triggerType}`, numKey = `trigger-num-${triggerNum}`;
        if (!patternMemory[typeKey]) patternMemory[typeKey] = {};
        if (!patternMemory[typeKey][resultType]) patternMemory[typeKey][resultType] = { attempts: 0, successes: 0 };
        patternMemory[typeKey][resultType].attempts++;
        patternMemory[typeKey][resultType].successes++;
        if (!patternMemory[numKey]) patternMemory[numKey] = {};
        if (!patternMemory[numKey][resultType]) patternMemory[numKey][resultType] = { attempts: 0, successes: 0 };
        patternMemory[numKey][resultType].attempts++;
        patternMemory[numKey][resultType].successes++;
    }
    if (successfulSpins.length < 3) return;
    const [sA, sB, sC] = successfulSpins.slice(-3);
    if (sA.hitTypes.length === 1 && sB.hitTypes.length === 1 && sC.hitTypes.length === 1) {
        const [tA, tB, tC] = [sA.hitTypes[0], sB.hitTypes[0], sC.hitTypes[0]];
        if (tA !== tB) {
            const pKey = `oscillation-${tA}-${tB}`;
            if (!patternMemory[pKey]) patternMemory[pKey] = { attempts: 0, successes: 0 };
            patternMemory[pKey].attempts++;
            if (tA === tC) patternMemory[pKey].successes++;
        }
    }
}

function evaluateCalculationStatus(item, winningNum) {
    item.hitTypes = [];
    item.typeSuccessStatus = {};
    let anyHit = false;
    const activeTypes = getActivePredictionTypes();
    const allTypes = getFullPredictionTypes();
    activeTypes.forEach(type => {
        const def = allTypes.find(t => t.id === type.id);
        if (!def) { item.typeSuccessStatus[type.id] = false; return; }
        const baseNum = def.calculateBase(item.num1, item.num2);
        if (baseNum < 0 || baseNum > 36) { item.typeSuccessStatus[type.id] = false; return; }
        const terminals = terminalMapping?.[baseNum] || [];
        const hitZone = getHitZone(baseNum, terminals, winningNum);
        if (hitZone.includes(winningNum)) {
            item.hitTypes.push(type.id);
            item.typeSuccessStatus[type.id] = true;
            anyHit = true;
        } else {
            item.typeSuccessStatus[type.id] = false;
        }
    });
    item.status = anyHit ? 'success' : 'fail';
    item.boardState = anyHit ? item.hitTypes.join(' & ') : 'none';
}

function labelHistoryFailures(sortedHistory) {
    if (sortedHistory.length < 3) return;
    for (let i = 2; i < sortedHistory.length; i++) {
        const current = sortedHistory[i];
        if (current.status === 'success') { current.failureMode = 'none'; continue; }
        current.failureMode = 'normalLoss';
        const prev = sortedHistory[i-1], prevPrev = sortedHistory[i-2];
        if (prev.winningNumber !== null && current.winningNumber !== null && calculatePocketDistance(current.winningNumber, prev.winningNumber) > 9) {
            current.failureMode = 'sectionShift';
            continue;
        }
        if (prev.status === 'success' && prevPrev.status === 'success') {
            const prevHits = new Set(prev.hitTypes), prevPrevHits = new Set(prevPrev.hitTypes);
            for (const hit of prevHits) {
                if (prevPrevHits.has(hit) && !current.typeSuccessStatus[hit]) {
                    current.failureMode = 'streakBreak';
                    break;
                }
            }
        }
    }
}

async function handleConfirmWinningNumber(calcId) {
    const winNumInput = document.getElementById('winningNumber');
    const winningNum = parseInt(winNumInput.value, 10);
    if (isNaN(winningNum) || winningNum < 0 || winningNum > 36) return;
    const item = history.find(i => i.id === calcId);
    if (!item) return;
    evaluateCalculationStatus(item, winningNum);
    item.winningNumber = winningNum;
    if (!confirmedWinsLog.includes(winningNum)) confirmedWinsLog.push(winningNum);
    updateStrategyWeights(item);
    updatePatternMemory();
    if (item.status === 'success') {
        let minPocketDist = Infinity;
        const allTypes = getFullPredictionTypes();
        item.hitTypes.forEach(typeId => {
            const type = allTypes.find(t => t.id === typeId);
            if (!type) return;
            const baseNum = type.calculateBase(item.num1, item.num2);
            if (baseNum < 0 || baseNum > 36) return;
            const terminals = terminalMapping?.[baseNum] || [];
            const hitZone = getHitZone(baseNum, terminals, winningNum);
            hitZone.forEach(zoneNum => {
                const dist = calculatePocketDistance(zoneNum, winningNum);
                if (dist < minPocketDist) minPocketDist = dist;
            });
        });
        item.pocketDistance = minPocketDist === Infinity ? null : minPocketDist;
    } else {
        item.pocketDistance = null;
    }
    if (item.recommendedGroupId && item.winningNumber !== null) {
        const recoDef = getFullPredictionTypes().find(t => t.id === item.recommendedGroupId);
        if (recoDef) {
            const baseNum = recoDef.calculateBase(item.num1, item.num2);
            if (baseNum >= 0 && baseNum <= 36) {
                const terminals = terminalMapping?.[baseNum] || [];
                const hitZone = getHitZone(baseNum, terminals, item.winningNumber);
                let minRecoDist = Infinity;
                hitZone.forEach(zoneNum => {
                    const dist = calculatePocketDistance(zoneNum, item.winningNumber);
                    if (dist < minRecoDist) minRecoDist = dist;
                });
                item.recommendedGroupPocketDistance = minRecoDist === Infinity ? null : minRecoDist;
            } else { item.recommendedGroupPocketDistance = null; }
        } else { item.recommendedGroupPocketDistance = null; }
    } else { item.recommendedGroupPocketDistance = null; }
    if (item.recommendedGroupId && item.recommendationDetails?.primaryDrivingFactor) {
        const factor = item.recommendationDetails.primaryDrivingFactor;
        if (adaptiveFactorInfluences[factor] === undefined) adaptiveFactorInfluences[factor] = 1.0;
        const hit = item.hitTypes.includes(item.recommendedGroupId);
        if (hit) adaptiveFactorInfluences[factor] = Math.min(ADAPTIVE_LEARNING_RATES.MAX_INFLUENCE, adaptiveFactorInfluences[factor] + ADAPTIVE_LEARNING_RATES.SUCCESS);
        else adaptiveFactorInfluences[factor] = Math.max(ADAPTIVE_LEARNING_RATES.MIN_INFLUENCE, adaptiveFactorInfluences[factor] - ADAPTIVE_LEARNING_RATES.FAILURE);
    }
    history.forEach((h, i) => {
        const slice = history.slice(0, i+1);
        const stats = calculateTrendStats(slice);
        let maxStreak = 0;
        if (h.status === 'success' && h.typeSuccessStatus) {
            h.hitTypes.forEach(typeId => {
                if (stats.currentStreaks[typeId] > maxStreak) maxStreak = stats.currentStreaks[typeId];
            });
        }
        h.confirmedStreak = maxStreak;
    });
    labelHistoryFailures(history.slice().sort((a,b) => a.id - b.id));
    runAllAnalyses();
    renderHistory();
    if (history.filter(i => i.status === 'success').length >= TRAINING_MIN_HISTORY) {
        isAiReady = false;
        document.getElementById('aiModelStatus').textContent = 'AI Model: Training...';
        aiWorker.postMessage({ type: 'train', payload: { history: history, historicalStreakData: calculateTrendStats().streakData } });
    } else {
        document.getElementById('aiModelStatus').textContent = `AI Model: Need at least ${TRAINING_MIN_HISTORY} confirmed spins to train. (Current: ${history.filter(i=>i.status==='success').length})`;
    }
    if (item) {
        document.getElementById('number1').value = item.num2;
        document.getElementById('number2').value = winningNum;
        setTimeout(() => handleCalculation(item.num2, winningNum), 100);
    }
    saveState();
}

async function getPredictionProbabilitiesFromWorker() {
    if (DEBUG_MODE) console.log('Main: Requesting prediction from worker.');
    const trendStats = calculateTrendStats();
    return new Promise(resolve => {
        const handler = e => {
            if (e.data.type === 'predictionResult') {
                aiWorker.removeEventListener('message', handler);
                resolve(e.data.probabilities || { groups: {}, failures: {}, streakPredictions: {} });
            }
        };
        aiWorker.addEventListener('message', handler);
        if (history.filter(i=>i.status==='success').length < AI_SEQUENCE_LENGTH) {
            resolve({ groups: {}, failures: {}, streakPredictions: {} });
            return;
        }
        aiWorker.postMessage({ type: 'predict', payload: { history, currentStreaksData: trendStats.currentStreaks, historicalStreakData: trendStats.streakData } });
    });
}

async function displayCalculationResult(diff, calcId) {
    if (DEBUG_MODE) console.log('Displaying calculation result...');
    const trendStats = calculateTrendStats(), boardStats = getBoardStateStats(), neighbourScores = runNeighbourAnalysis(false);
    const predictionData = isAiReady ? await getPredictionProbabilitiesFromWorker() : { groups: {}, failures: {}, streakPredictions: {} };
    const reco = getRecommendation(trendStats, boardStats, neighbourScores, diff, parseInt(dom.number1.value, 10), parseInt(dom.number2.value, 10), false, predictionData, adaptiveFactorInfluences);
    const num1 = parseInt(dom.number1.value, 10), num2 = parseInt(dom.number2.value, 10);
    const lastWin = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length-1] : null;
    let groupInfoHtml = '';
    const activeTypes = getActivePredictionTypes();
    const allTypes = getFullPredictionTypes();
    activeTypes.forEach(type => {
        if (isNaN(num1) || isNaN(num2)) return;
        const def = allTypes.find(t => t.id === type.id);
        if (!def) return;
        const baseNum = def.calculateBase(num1, num2);
        if (baseNum < 0 || baseNum > 36) return;
        const terminals = terminalMapping?.[baseNum] || [], avgTrend = parseFloat(trendStats.averages?.[type.id])||0, hitRate = boardStats?.[type.id]?.total > 0 ? (boardStats?.[type.id]?.success / boardStats?.[type.id]?.total * 100).toFixed(2)+'%' : '0.00%', currentStreak = trendStats.currentStreaks?.[type.id]??0;
        let confirmationHtml = currentStreak >= 2 ? `<span class="text-green-600">- confirmed by ${currentStreak}</span>` : '';
        let pocketDistHtml = '';
        if (usePocketDistance && lastWin !== null) {
            const hitZone = getHitZone(baseNum, terminals, lastWin);
            let minDist = Infinity;
            hitZone.forEach(zoneNum => { const dist = calculatePocketDistance(zoneNum, lastWin); if (dist < minDist) minDist = dist; });
            pocketDistHtml = ` (<span class="text-pink-400">Dist: ${minDist}</span>)`;
        }
        const mlProb = (predictionData?.groups?.[type.id] ?? 0) * 100;
        const mlDisplay = ` (AI: ${mlProb.toFixed(1)}%)`;
        let streakPredHtml = '';
        const predAvgStreak = predictionData?.streakPredictions?.[type.id] ?? 0;
        if (isAiReady && predAvgStreak > 1.5) streakPredHtml = `<br><span class="text-xs text-gray-600">AI Est. Streak Length: ${predAvgStreak.toFixed(1)}.${currentStreak>0?` (Current: ${currentStreak})`:''}</span>`;
        groupInfoHtml += `<p><strong class="capitalize" style="color: ${type.textColor};">${type.displayLabel} (${baseNum}):</strong> ${terminals.join(', ')||'None'} <span class="text-xs text-gray-500">(Avg Trend: ${avgTrend}) ${hitRate}${mlDisplay}</span> ${confirmationHtml}${pocketDistHtml}${streakPredHtml}</p>`;
    });
    let failureHtml = '';
    if (isAiReady && predictionData?.failures) {
        const risk = Object.entries(predictionData.failures).filter(([m,_])=>m!=='none'&&m!=='normalLoss').sort((a,b)=>b[1]-a[1])[0];
        if (risk && risk[1] > 0.3) failureHtml = `<div class="mt-4 p-3 bg-yellow-100 border border-yellow-300 rounded-lg text-center text-sm"><strong class="text-yellow-800">AI Risk Analysis:</strong> High chance (${(risk[1]*100).toFixed(0)}%) of a <strong>${risk[0]==='streakBreak'?'Streak Break':'Section Shift'}</strong>.</div>`;
    }
    const patternHtml = reco.patternInfo ? `<div class="pattern-alert">${reco.patternInfo}</div>` : '';
    dom.resultDisplay.innerHTML = `<div class="result-display space-y-4">${patternHtml}<h3 class="text-center font-bold text-lg">Calculation Result: ${diff}</h3><div class="text-sm space-y-2">${groupInfoHtml}</div><div class="text-center pt-2 font-semibold">${reco.html}</div>${failureHtml}<div class="flex items-center space-x-2 pt-2"><input type="number" id="winningNumber" placeholder="Winning #" class="form-input flex-grow"><button id="confirmWinBtn" class="btn btn-primary px-4">Confirm</button></div></div>`;
    dom.resultDisplay.classList.remove('hidden');
    document.getElementById('confirmWinBtn').addEventListener('click', () => handleConfirmWinningNumber(calcId));
    document.getElementById('winningNumber').addEventListener('keydown', e => { if (e.key==='Enter') handleConfirmWinningNumber(calcId); });
    drawRouletteWheel(diff, lastWin);
}

async function handleCalculation(num1, num2) {
    const n1 = num1 !== undefined ? num1 : parseInt(dom.number1.value, 10);
    const n2 = num2 !== undefined ? num2 : parseInt(dom.number2.value, 10);
    if (isNaN(n1) || isNaN(n2)) { dom.resultDisplay.innerHTML = `<div class="result-display text-center font-semibold text-red-600">Please enter valid numbers in both fields.</div>`; dom.resultDisplay.classList.remove('hidden'); return; }
    const calcId = Date.now();
    const difference = Math.abs(n2 - n1);
    const initialStatus = {};
    getActivePredictionTypes().forEach(t => initialStatus[t.id] = false);
    let predictionData = null;
    if (isAiReady && history.filter(i=>i.status==='success').length >= AI_SEQUENCE_LENGTH) {
        predictionData = await getPredictionProbabilitiesFromWorker();
    }
    const reco = getRecommendation(calculateTrendStats(), getBoardStateStats(), runNeighbourAnalysis(false), difference, n1, n2, false, predictionData, adaptiveFactorInfluences);
    const newItem = { id: calcId, num1: n1, num2: n2, difference, status: 'pending', hitTypes: [], typeSuccessStatus: initialStatus, confirmedStreak: 0, pocketDistance: null, winningNumber: null, recommendedGroupId: reco.bestCandidate?.type.id || null, recommendationDetails: reco.bestCandidate?.details || null };
    history.push(newItem);
    await displayCalculationResult(difference, calcId);
    renderHistory();
    saveState();
}

function runBoardStateAnalysis(simulatedHistory = history) {
    const stats = getBoardStateStats(simulatedHistory);
    const container = document.getElementById('boardStateAnalysis');
    container.innerHTML = '';
    const sortedStats = Object.entries(stats).sort(([,a], [,b]) => (b.success/b.total || 0) - (a.success/a.total || 0));
    const allTypes = getFullPredictionTypes();
    sortedStats.forEach(([typeId, {success, total}]) => {
        const type = allTypes.find(t => t.id === typeId);
        if (!type) return;
        const hitRate = total > 0 ? (success / total * 100) : 0;
        container.innerHTML += `<div class="text-sm"><strong style="color:${type.textColor};">${type.displayLabel}:</strong> ${hitRate.toFixed(2)}% Hit Rate</div>`;
    });
    document.getElementById('boardStateConclusion').textContent = sortedStats.length > 0 ? `Current Top Group: ${allTypes.find(t=>t.id===sortedStats[0][0])?.displayLabel || 'N/A'}` : '';
}

function runNeighbourAnalysis(render = true, simulatedHistory = history) {
    const analysis = {};
    for (let i=0; i<=36; i++) analysis[i] = { success: 0 };
    simulatedHistory.forEach((item, i) => {
        if (item.status !== 'success') return;
        const weight = Math.pow(STRATEGY_CONFIG.decayFactor, simulatedHistory.length - 1 - i);
        const allTypes = getFullPredictionTypes();
        item.hitTypes.forEach(typeId => {
            const type = allTypes.find(t => t.id === typeId);
            if (!type) return;
            const baseNum = type.calculateBase(item.num1, item.num2);
            if (baseNum < 0 || baseNum > 36) return;
            const terminals = terminalMapping[baseNum] || [];
            const points = {};
            let baseNeighbourCount = (terminals.length === 1) ? 3 : (terminals.length >= 2) ? 1 : 0;
            if (baseNeighbourCount > 0) getNeighbours(baseNum, baseNeighbourCount).forEach(n => { points[n] = (points[n] || 0) + 1; });
            let terminalNeighbourCount = (terminals.length === 1 || terminals.length === 2) ? 3 : (terminals.length > 2) ? 1 : 0;
            if (useDynamicTerminalNeighbourCount && item.winningNumber !== null && (baseNum === item.winningNumber || terminals.includes(item.winningNumber))) terminalNeighbourCount = 0;
            if (terminalNeighbourCount > 0) terminals.forEach(t => getNeighbours(t, terminalNeighbourCount).forEach(n => { points[n] = (points[n] || 0) + 1; }));
            for (const num in points) if (analysis[num]) analysis[num].success += points[num] * weight;
        });
    });
    if (render) {
        const list = document.getElementById('analysisList');
        list.innerHTML = `<li class="text-center text-gray-500 py-4">Not enough data.</li>`;
        const sorted = Object.entries(analysis).map(([num,s])=>({num:parseInt(num),score:s.success})).sort((a,b)=>b.score-a.score);
        if (sorted.every(a=>a.score===0) && history.filter(i=>i.status==='success').length===0) return;
        list.innerHTML = '';
        sorted.forEach(({num,score})=>{
            const li = document.createElement('li');
            li.innerHTML = `<div class="grid grid-cols-2 items-center p-2 rounded-md ${score>0?'bg-green-50':''}"><div class="font-bold text-lg text-center text-indigo-600">${num}</div><div class="font-semibold text-center ${score>0?'text-green-700':'text-gray-600'}">Score: ${score.toFixed(2)}</div></div>`;
            list.appendChild(li);
        });
    }
    return analysis;
}

function runAllAnalyses() {
    runBoardStateAnalysis();
    runNeighbourAnalysis();
    renderStrategyWeights();
}

function createSlider(containerId, label, paramObj, paramName, min, max, step) {
    const container = document.getElementById(containerId);
    const id = `${paramName}Slider`;
    const group = document.createElement('div');
    group.className = 'slider-group';
    group.innerHTML = `<label for="${id}">${label}</label><input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}"><input type="number" id="${id}Input" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}" class="form-input text-sm">`;
    container.appendChild(group);
    const slider = document.getElementById(id), numInput = document.getElementById(`${id}Input`);
    const update = (src, tgt) => {
        let val = parseFloat(src.value);
        if (isNaN(val)) val = DEFAULT_PARAMETERS[paramObj===STRATEGY_CONFIG?'STRATEGY_CONFIG':'ADAPTIVE_LEARNING_RATES'][paramName];
        val = Math.max(min, Math.min(max, val));
        tgt.value = val;
        src.value = val;
        paramObj[paramName] = val;
        saveState();
        document.getElementById('parameterStatusMessage').textContent = 'Parameter changed. Re-analyzing...';
        handleStrategyChange();
    };
    slider.addEventListener('input', () => update(slider, numInput));
    numInput.addEventListener('change', () => update(numInput, slider));
}

function initializeAdvancedSettingsUI() {
    const sliders = { strategyLearningRatesSliders: '', patternThresholdsSliders: '', adaptiveInfluenceSliders: '' };
    for (const key in sliders) document.getElementById(key).innerHTML = '';
    createSlider('strategyLearningRatesSliders', 'Success Learn Rate', STRATEGY_CONFIG, 'learningRate_success', 0.01, 1.0, 0.01);
    createSlider('strategyLearningRatesSliders', 'Failure Learn Rate', STRATEGY_CONFIG, 'learningRate_failure', 0.01, 0.5, 0.01);
    createSlider('strategyLearningRatesSliders', 'Max Weight', STRATEGY_CONFIG, 'maxWeight', 1.0, 10.0, 0.1);
    createSlider('strategyLearningRatesSliders', 'Min Weight', STRATEGY_CONFIG, 'minWeight', 0.0, 1.0, 0.01);
    createSlider('strategyLearningRatesSliders', 'Decay Factor', STRATEGY_CONFIG, 'decayFactor', 0.7, 0.99, 0.01);
    createSlider('patternThresholdsSliders', 'Pattern Min Attempts', STRATEGY_CONFIG, 'patternMinAttempts', 1, 20, 1);
    createSlider('patternThresholdsSliders', 'Pattern Success %', STRATEGY_CONFIG, 'patternSuccessThreshold', 50, 100, 1);
    createSlider('patternThresholdsSliders', 'Trigger Min Attempts', STRATEGY_CONFIG, 'triggerMinAttempts', 1, 20, 1);
    createSlider('patternThresholdsSliders', 'Trigger Success %', STRATEGY_CONFIG, 'triggerSuccessThreshold', 50, 100, 1);
    createSlider('adaptiveInfluenceSliders', 'Adaptive Success Rate', ADAPTIVE_LEARNING_RATES, 'SUCCESS', 0.01, 0.5, 0.01);
    createSlider('adaptiveInfluenceSliders', 'Adaptive Failure Rate', ADAPTIVE_LEARNING_RATES, 'FAILURE', 0.01, 0.5, 0.01);
    createSlider('adaptiveInfluenceSliders', 'Min Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MIN_INFLUENCE', 0.0, 1.0, 0.01);
    createSlider('adaptiveInfluenceSliders', 'Max Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MAX_INFLUENCE', 1.0, 5.0, 0.1);
}

function resetAllParameters() {
    Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
    Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
    Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => window[key] = DEFAULT_PARAMETERS.TOGGLES[key]);
    updateAllTogglesUI();
    initializeAdvancedSettingsUI();
    saveState();
    document.getElementById('parameterStatusMessage').textContent = 'Parameters reset to defaults.';
    handleStrategyChange();
}

function saveParametersToFile() {
    const params = { STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES, TOGGLES: { useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance, useLowestPocketDistance, useAdvancedCalculations, useDynamicStrategy, useAdaptivePlay, useTableChangeWarnings, useDueForHit, useNeighbourFocus, useLessStrict, useDynamicTerminalNeighbourCount } };
    const data = JSON.stringify(params, null, 2);
    const blob = new Blob([data], {type: 'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'roulette_parameters.json';
    a.click();
    URL.revokeObjectURL(a.href);
    document.getElementById('parameterStatusMessage').textContent = 'Parameters saved.';
}

async function loadParametersFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    const text = await file.text();
    try {
        const params = JSON.parse(text);
        if (params.STRATEGY_CONFIG) Object.assign(STRATEGY_CONFIG, params.STRATEGY_CONFIG);
        if (params.ADAPTIVE_LEARNING_RATES) Object.assign(ADAPTIVE_LEARNING_RATES, params.ADAPTIVE_LEARNING_RATES);
        if (params.TOGGLES) Object.keys(params.TOGGLES).forEach(key => { if (window.hasOwnProperty(key)) window[key] = params.TOGGLES[key]; });
        updateAllTogglesUI();
        initializeAdvancedSettingsUI();
        saveState();
        document.getElementById('parameterStatusMessage').textContent = 'Parameters loaded.';
        handleStrategyChange();
    } catch (e) {
        document.getElementById('parameterStatusMessage').textContent = `Error loading file: ${e.message}`;
    } finally {
        event.target.value = '';
    }
}

function toggleParameterSliders(enable) {
    const container = document.getElementById('advancedSettingsContent');
    if (container) container.querySelectorAll('input, button').forEach(c => c.disabled = !enable);
    document.getElementById('setHighestWinRatePreset').disabled = !enable;
    document.getElementById('setBalancedSafePreset').disabled = !enable;
    document.getElementById('setAggressiveSignalsPreset').disabled = !enable;
    document.getElementById('resetParametersButton').disabled = !enable;
    document.getElementById('saveParametersButton').disabled = !enable;
    document.getElementById('loadParametersLabel').classList.toggle('btn-disabled', !enable);
}


// ===============================================
// DOMContentLoaded - APPLICATION STARTUP
// ===============================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        const terminalMapping = {
            0: [4, 6], 1: [8], 2: [7, 9], 3: [8], 4: [11], 5: [12, 10], 6: [11], 7: [14, 2],
            8: [15, 13, 3, 1], 9: [14, 2], 10: [17, 5], 11: [18, 16, 6, 4], 12: [17, 5],
            13: [20, 23], 14: [9, 21, 7, 19], 15: [8, 20], 16: [11], 17: [12, 24, 10, 22],
            18: [11, 23], 19: [14, 26], 20: [13, 25, 15, 27], 21: [14, 26], 22: [17, 29],
            23: [18, 30, 16, 28], 24: [17, 29], 25: [20, 32], 26: [19, 31, 33, 21],
            27: [20, 32], 28: [23, 35], 29: [22, 34, 24, 36], 30: [23, 35], 31: [26],
            32: [25, 27], 33: [26], 34: [29], 35: [28, 30], 36: [29]
        };
        const clonablePredictionTypes = getFullPredictionTypes().map(type => ({
            id: type.id, label: type.label, displayLabel: type.displayLabel,
            colorClass: type.colorClass, textColor: type.textColor
        }));
        const dom = {
            number1: document.getElementById('number1'), number2: document.getElementById('number2'),
            resultDisplay: document.getElementById('resultDisplay'), historyList: document.getElementById('historyList'),
            analysisList: document.getElementById('analysisList'), boardStateAnalysis: document.getElementById('boardStateAnalysis'),
            boardStateConclusion: document.getElementById('boardStateConclusion'), historicalNumbersInput: document.getElementById('historicalNumbersInput'),
            imageUpload: document.getElementById('imageUpload'), imageUploadLabel: document.getElementById('imageUploadLabel'),
            analyzeHistoricalDataButton: document.getElementById('analyzeHistoricalDataButton'), historicalAnalysisMessage: document.getElementById('historicalAnalysisMessage'),
            aiModelStatus: document.getElementById('aiModelStatus'), recalculateAnalysisButton: document.getElementById('recalculateAnalysisButton'),
            trendConfirmationToggle: document.getElementById('trendConfirmationToggle'), weightedZoneToggle: document.getElementById('weightedZoneToggle'),
            proximityBoostToggle: document.getElementById('proximityBoostToggle'), pocketDistanceToggle: document.getElementById('pocketDistanceToggle'),
            lowestPocketDistanceToggle: document.getElementById('lowestPocketDistanceToggle'), advancedCalculationsToggle: document.getElementById('advancedCalculationsToggle'),
            dynamicStrategyToggle: document.getElementById('dynamicStrategyToggle'), adaptivePlayToggle: document.getElementById('adaptivePlayToggle'),
            tableChangeWarningsToggle: document.getElementById('tableChangeWarningsToggle'), dueForHitToggle: document.getElementById('dueForHitToggle'),
            neighbourFocusToggle: document.getElementById('neighbourFocusToggle'), lessStrictModeToggle: document.getElementById('lessStrictModeToggle'),
            dynamicTerminalNeighbourCountToggle: document.getElementById('dynamicTerminalNeighbourCountToggle'), videoUpload: document.getElementById('videoUpload'),
            videoUploadLabel: document.getElementById('videoUploadLabel'), videoStatus: document.getElementById('videoStatus'),
            videoPlayer: document.getElementById('videoPlayer'), frameCanvas: document.getElementById('frameCanvas'),
            setHighestWinRatePreset: document.getElementById('setHighestWinRatePreset'), setBalancedSafePreset: document.getElementById('setBalancedSafePreset'),
            setAggressiveSignalsPreset: document.getElementById('setAggressiveSignalsPreset'), rouletteWheelContainer: document.getElementById('rouletteWheelContainer'),
            rouletteLegend: document.getElementById('rouletteLegend'), strategyWeightsDisplay: document.getElementById('strategyWeightsDisplay'),
            videoUploadContainer: document.getElementById('videoUploadContainer'), videoControlsContainer: document.getElementById('videoControlsContainer'),
            analyzeVideoButton: document.getElementById('analyzeVideoButton'), clearVideoButton: document.getElementById('clearVideoButton'),
            historyInfoToggle: document.getElementById('historyInfoToggle'), historyInfoDropdown: document.getElementById('historyInfoDropdown'),
            winCount: document.getElementById('winCount'), lossCount: document.getElementById('lossCount'),
            advancedSettingsHeader: document.getElementById('advancedSettingsHeader'), advancedSettingsContent: document.getElementById('advancedSettingsContent'),
            strategyLearningRatesSliders: document.getElementById('strategyLearningRatesSliders'), patternThresholdsSliders: document.getElementById('patternThresholdsSliders'),
            adaptiveInfluenceSliders: document.getElementById('adaptiveInfluenceSliders'), resetParametersButton: document.getElementById('resetParametersButton'),
            saveParametersButton: document.getElementById('saveParametersButton'), loadParametersInput: document.getElementById('loadParametersInput'),
            loadParametersLabel: document.getElementById('loadParametersLabel'), parameterStatusMessage: document.getElementById('parameterStatusMessage'),
            optimizationStatus: document.getElementById('optimizationStatus'), optimizationResult: document.getElementById('optimizationResult'),
            startOptimizationButton: document.getElementById('startOptimizationButton'), stopOptimizationButton: document.getElementById('stopOptimizationButton'),
            applyBestParamsButton: document.getElementById('applyBestParamsButton')
        };
        
        function saveState() {
            localStorage.setItem('terminalCalculatorState', JSON.stringify({
                history, confirmedWinsLog, strategyStates, patternMemory, adaptiveFactorInfluences, STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES,
                TOGGLES: { useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance, useLowestPocketDistance, useAdvancedCalculations, useDynamicStrategy, useAdaptivePlay, useTableChangeWarnings, useDueForHit, useNeighbourFocus, useLessStrict, useDynamicTerminalNeighbourCount }
            }));
        }
        function loadState() {
            const savedState = localStorage.getItem('terminalCalculatorState');
            if (savedState) {
                const appState = JSON.parse(savedState);
                history = (appState.history || []).map(item => ({...item, recommendedGroupId: item.recommendedGroupId || null, recommendationDetails: item.recommendationDetails || null}));
                confirmedWinsLog = appState.confirmedWinsLog || [];
                if (appState.TOGGLES) Object.keys(appState.TOGGLES).forEach(key => window[key] = appState.TOGGLES[key] ?? DEFAULT_PARAMETERS.TOGGLES[key]);
                else Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => window[key] = DEFAULT_PARAMETERS.TOGGLES[key]);
                if (appState.strategyStates) strategyStates = appState.strategyStates;
                if (appState.patternMemory) patternMemory = appState.patternMemory;
                if (appState.adaptiveFactorInfluences) Object.assign(adaptiveFactorInfluences, appState.adaptiveFactorInfluences);
                if (appState.STRATEGY_CONFIG) Object.assign(STRATEGY_CONFIG, appState.STRATEGY_CONFIG);
                else Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                if (appState.ADAPTIVE_LEARNING_RATES) Object.assign(ADAPTIVE_LEARNING_RATES, appState.ADAPTIVE_LEARNING_RATES);
                else Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                updateAllTogglesUI();
                updateActivePredictionTypes();
                initializeAdvancedSettingsUI();
            } else {
                Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => window[key] = DEFAULT_PARAMETERS.TOGGLES[key]);
                updateAllTogglesUI();
                updateActivePredictionTypes();
                initializeAdvancedSettingsUI();
            }
        }
        function updateAllTogglesUI() {
            Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => {
                const toggleId = key.replace('use', '').charAt(0).toLowerCase() + key.slice(4) + 'Toggle';
                if(dom[toggleId]) dom[toggleId].checked = window[key];
            });
        }
        function updateActivePredictionTypes() {
            updateRouletteLegend();
            if (aiWorker) aiWorker.postMessage({ type: 'update_config', payload: { allPredictionTypes: clonablePredictionTypes, terminalMapping: terminalMapping, history: history } });
        }
        function updateRouletteLegend() {
            dom.rouletteLegend.innerHTML = `<div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-green"></div> Green (0)</div><div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-red"></div> Red Numbers</div><div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-black"></div> Black Numbers</div>`;
            getActivePredictionTypes().forEach(type => {
                dom.rouletteLegend.innerHTML += `<div class="roulette-legend-item"><div class="roulette-legend-color ${type.colorClass}"></div> ${type.displayLabel}</div>`;
            });
            dom.rouletteLegend.innerHTML += `<div class="roulette-legend-item"><div class="roulette-legend-color bg-highlight-winning"></div> Winning Number</div>`;
        }
        function handlePresetSelection(preset) {
            if (preset === 'highestWinRate') {
                Object.assign(STRATEGY_CONFIG, {learningRate_success: 0.35, learningRate_failure: 0.05, maxWeight: 6.0, minWeight: 0.03, decayFactor: 0.88, patternMinAttempts: 5, patternSuccessThreshold: 68, triggerMinAttempts: 5, triggerSuccessThreshold: 63});
                Object.assign(ADAPTIVE_LEARNING_RATES, {SUCCESS: 0.15, FAILURE: 0.1, MIN_INFLUENCE: 0.2, MAX_INFLUENCE: 2.5});
                Object.assign(window, {useTrendConfirmation: true, useWeightedZone: true, useProximityBoost: false, usePocketDistance: false, useLowestPocketDistance: false, useAdvancedCalculations: true, useDynamicStrategy: true, useAdaptivePlay: true, useTableChangeWarnings: false, useDueForHit: false, useNeighbourFocus: true, useLessStrict: false, useDynamicTerminalNeighbourCount: true});
            } else if (preset === 'balancedSafe' || preset === 'aggressiveSignals') {
                Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                Object.assign(window, DEFAULT_PARAMETERS.TOGGLES);
                if (preset === 'aggressiveSignals') window.useLessStrict = true;
            }
            updateAllTogglesUI();
            initializeAdvancedSettingsUI();
            updateActivePredictionTypes();
            saveState();
            runAllAnalyses();
        }
        function handleImageUpload(event) {
            const file = event.target.files[0]; if(!file) return;
            if (GOOGLE_API_KEY === "YOUR_API_KEY_HERE") { dom.videoStatus.textContent = 'Error: API Key not set.'; return; }
            dom.historicalAnalysisMessage.textContent = 'Reading image...';
            dom.imageUploadLabel.classList.add('btn-disabled'); dom.imageUploadLabel.disabled = true;
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = async () => {
                try {
                    dom.historicalAnalysisMessage.textContent = 'Analyzing image...';
                    const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${GOOGLE_API_KEY}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ requests: [{ image: { content: reader.result.split(',')[1] }, features: [{ type: 'TEXT_DETECTION' }] }] }) });
                    if (!res.ok) throw new Error((await res.json()).error?.message || 'API request failed.');
                    const data = await res.json();
                    const text = data.responses[0]?.fullTextAnnotation?.text;
                    if (text) {
                        const nums = text.match(/\d+/g);
                        if (nums?.length) { dom.historicalNumbersInput.value = nums.join(' '); dom.historicalAnalysisMessage.textContent = `Success! Found ${nums.length} numbers.`; }
                        else dom.historicalAnalysisMessage.textContent = 'Could not find numbers in image.';
                    } else dom.historicalAnalysisMessage.textContent = 'No text detected in image.';
                } catch (e) { dom.historicalAnalysisMessage.textContent = `Error: ${e.message}`; }
                finally { dom.imageUploadLabel.classList.remove('btn-disabled'); dom.imageUploadLabel.disabled = false; setTimeout(() => dom.historicalAnalysisMessage.textContent = '', 5000); }
            };
            reader.onerror = () => { dom.historicalAnalysisMessage.textContent = 'Error reading image file.'; dom.imageUploadLabel.classList.remove('btn-disabled'); dom.imageUploadLabel.disabled = false; };
        }
        function handleVideoUpload(event) {
            const file = event.target.files[0]; if (!file) return;
            clearVideoState(false);
            if (currentVideoURL) URL.revokeObjectURL(currentVideoURL);
            currentVideoURL = URL.createObjectURL(file);
            dom.videoPlayer.src = currentVideoURL;
            dom.videoPlayer.classList.remove('hidden');
            dom.videoUploadContainer.classList.add('hidden');
            dom.videoControlsContainer.classList.remove('hidden');
        }
        function startVideoAnalysis() {
            if (typeof cv === 'undefined') { dom.videoStatus.textContent = 'Error: OpenCV.js is not ready.'; return; }
            let frameFound = false, frameId = null;
            dom.videoPlayer.oncanplay = () => {
                dom.videoStatus.textContent = 'Analyzing for still frame...';
                dom.videoPlayer.play();
                const c1 = document.createElement('canvas'), ctx1 = c1.getContext('2d');
                const c2 = document.createElement('canvas'), ctx2 = c2.getContext('2d');
                c1.width = c2.width = dom.videoPlayer.videoWidth; c1.height = c2.height = dom.videoPlayer.videoHeight;
                ctx2.drawImage(dom.videoPlayer, 0, 0, c1.width, c1.height);
                let stillCount = 0;
                function findFrame() {
                    if (frameFound || dom.videoPlayer.ended || (dom.videoPlayer.paused && !frameFound)) {
                        cancelAnimationFrame(frameId);
                        if (!frameFound) dom.videoStatus.textContent = 'No still frame found.';
                        return;
                    }
                    ctx1.drawImage(dom.videoPlayer, 0, 0, c1.width, c1.height);
                    const d1 = ctx1.getImageData(0,0,c1.width,c1.height).data;
                    const d2 = ctx2.getImageData(0,0,c2.width,c2.height).data;
                    let diff = 0;
                    for (let i=0; i<d1.length; i+=4) diff += Math.abs(d1[i]-d2[i]) + Math.abs(d1[i+1]-d2[i+1]) + Math.abs(d1[i+2]-d2[i+2]);
                    if (diff / (c1.width*c1.height*3) < 2) stillCount++; else stillCount = 0;
                    if (stillCount >= 5) {
                        frameFound = true; dom.videoPlayer.pause(); cancelAnimationFrame(frameId);
                        dom.videoStatus.textContent = 'Still frame found! Processing...'; processGoldenFrame(c1);
                    }
                    ctx2.drawImage(c1, 0, 0);
                    frameId = requestAnimationFrame(findFrame);
                }
                frameId = requestAnimationFrame(findFrame);
            };
            if (dom.videoPlayer.readyState >= 3) dom.videoPlayer.oncanplay();
        }
        function clearVideoState(clearStatus = true) {
            if(currentVideoURL) { URL.revokeObjectURL(currentVideoURL); currentVideoURL = null; }
            dom.videoPlayer.pause(); dom.videoPlayer.removeAttribute('src'); dom.videoPlayer.load();
            dom.videoPlayer.classList.add('hidden'); dom.frameCanvas.classList.add('hidden');
            if(clearStatus) dom.videoStatus.textContent = '';
            dom.videoUploadContainer.classList.remove('hidden');
            dom.videoControlsContainer.classList.add('hidden');
        }
        async function processGoldenFrame(canvas) {
             try {
                const frameCtx = dom.frameCanvas.getContext('2d');
                dom.frameCanvas.width = canvas.width; dom.frameCanvas.height = canvas.height;
                frameCtx.drawImage(canvas, 0, 0); dom.frameCanvas.classList.remove('hidden');
                const src = cv.imread(canvas), gray = new cv.Mat(), roi = gray.roi(new cv.Rect(canvas.width*0.4, canvas.height*0.1, canvas.width*0.2, canvas.height*0.2)), processed = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.adaptiveThreshold(roi, processed, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 115, 4);
                const tempCanvas = document.createElement('canvas');
                cv.imshow(tempCanvas, processed);
                dom.videoStatus.textContent = 'Reading number...';
                const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${GOOGLE_API_KEY}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ requests: [{ image: { content: tempCanvas.toDataURL('image/png').split(',')[1] }, features: [{ type: 'TEXT_DETECTION' }] }] }) });
                if (!res.ok) throw new Error((await res.json()).error?.message || 'API request failed.');
                const data = await res.json();
                const numMatch = data.responses[0]?.fullTextAnnotation?.text?.match(/\d+/);
                if (numMatch) {
                    const num = parseInt(numMatch[0], 10);
                    dom.videoStatus.textContent = `Detected Number: ${num}`;
                    const winInput = dom.resultDisplay?.querySelector('#winningNumber');
                    if (winInput) winInput.value = num;
                    else dom.videoStatus.textContent = `Detected ${num}, but no active calculation.`;
                } else dom.videoStatus.textContent = 'Could not read a number from the frame.';
                src.dispose(); gray.dispose(); roi.dispose(); processed.dispose();
            } catch (e) { dom.videoStatus.textContent = `Error during video processing: ${e.message}`; }
        }
        function handleSwap() { const v = dom.number1.value; dom.number1.value = dom.number2.value; dom.number2.value = v; }
        function handleHistoryAction(event) {
            const button = event.target.closest('.delete-btn');
            if (!button) return;
            history = history.filter(item => item.id !== parseInt(button.dataset.id));
            confirmedWinsLog = history.map(item => item.winningNumber).filter(n => n !== null).reverse();
            labelHistoryFailures(history.slice().sort((a, b) => a.id - b.id));
            history.forEach((h, i) => {
                const slice = history.slice(0, i+1), stats = calculateTrendStats(slice);
                let maxStreak = 0;
                if (h.status === 'success') h.hitTypes.forEach(t => { if (stats.currentStreaks[t] > maxStreak) maxStreak = stats.currentStreaks[t]; });
                h.confirmedStreak = maxStreak;
            });
            runAllAnalyses(); renderHistory(); drawRouletteWheel(); saveState();
            const successCount = history.filter(i => i.status === 'success').length;
            isAiReady = false;
            if (successCount >= TRAINING_MIN_HISTORY) {
                dom.aiModelStatus.textContent = 'AI Model: Training...';
                aiWorker.postMessage({ type: 'train', payload: { history: history } });
            } else {
                dom.aiModelStatus.textContent = `AI Model: Need ${TRAINING_MIN_HISTORY} confirmed spins.`;
                aiWorker.postMessage({ type: 'clear_model' });
            }
        }
        function handleClearInputs() {
            dom.number1.value = ''; dom.number2.value = '';
            dom.resultDisplay.classList.add('hidden');
            dom.number1.focus(); drawRouletteWheel();
        }
        function handleClearHistory() {
            history = []; confirmedWinsLog = []; patternMemory = {};
            Object.assign(adaptiveFactorInfluences, {'Hit Rate':1.0,'Streak':1.0,'Proximity to Last Spin':1.0,'Hot Zone Weighting':1.0,'High AI Confidence':1.0,'Statistical Trends':1.0});
            isAiReady = false;
            dom.aiModelStatus.textContent = `AI Model: Need ${TRAINING_MIN_HISTORY} confirmed spins.`;
            runAllAnalyses(); renderHistory(); saveState();
            dom.historicalAnalysisMessage.textContent = 'History cleared.';
            drawRouletteWheel();

            aiWorker.postMessage({ type: 'clear_model' });
        }

        // --- ATTACH EVENT LISTENERS ---
        document.addEventListener('click', function(event) {
            if (event.target.id === 'calculateButton') handleCalculation();
            else if (event.target.id === 'clearInputsButton') handleClearInputs();
            else if (event.target.closest('#swapButton')) handleSwap();
            else if (event.target.id === 'clearHistoryButton') handleClearHistory();
            else if (event.target.closest('.delete-btn')) handleHistoryAction(event);
            else if (event.target.id === 'analyzeHistoricalDataButton') handleHistoricalAnalysis();
            else if (event.target.id === 'recalculateAnalysisButton') runAllAnalyses();
            else if (event.target.id === 'analyzeVideoButton') startVideoAnalysis();
            else if (event.target.id === 'clearVideoButton') clearVideoState();
            else if (event.target.id === 'setHighestWinRatePreset') handlePresetSelection('highestWinRate');
            else if (event.target.id === 'setBalancedSafePreset') handlePresetSelection('balancedSafe');
            else if (event.target.id === 'setAggressiveSignalsPreset') handlePresetSelection('aggressiveSignals');
            else if (event.target.id === 'resetParametersButton') resetAllParameters();
            else if (event.target.id === 'saveParametersButton') saveParametersToFile();
            else if (event.target.id === 'startOptimizationButton') {
                if (history.length < 20) { dom.optimizationStatus.textContent = 'Error: Need at least 20 history items.'; return; }
                dom.optimizationStatus.textContent = 'Starting optimization...';
                dom.optimizationResult.classList.add('hidden');
                toggleParameterSliders(false);
                dom.startOptimizationButton.disabled = true;
                dom.stopOptimizationButton.disabled = false;
                const helpers = {
                    calculateTrendStats: calculateTrendStats.toString(), getBoardStateStats: getBoardStateStats.toString(),
                    getRecommendation: getRecommendation.toString(), runNeighbourAnalysis: runNeighbourAnalysis.toString(),
                    getHitZone: getHitZone.toString(), getNeighbours: getNeighbours.toString(),
                    calculatePocketDistance: calculatePocketDistance.toString(), allPredictionTypes: clonablePredictionTypes,
                    terminalMapping: terminalMapping, rouletteWheel: [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32]
                };
                optimizationWorker.postMessage({ type: 'start', payload: { history, helpers } });
            }
            else if (event.target.id === 'stopOptimizationButton') optimizationWorker.postMessage({ type: 'stop' });
            else if (event.target.id === 'applyBestParamsButton') {
                if (bestFoundParams) {
                    Object.assign(STRATEGY_CONFIG, {learningRate_success: bestFoundParams.learningRate_success, learningRate_failure: bestFoundParams.learningRate_failure, maxWeight: bestFoundParams.maxWeight, minWeight: bestFoundParams.minWeight, decayFactor: bestFoundParams.decayFactor, patternMinAttempts: bestFoundParams.patternMinAttempts, patternSuccessThreshold: bestFoundParams.patternSuccessThreshold, triggerMinAttempts: bestFoundParams.triggerMinAttempts, triggerSuccessThreshold: bestFoundParams.triggerSuccessThreshold});
                    Object.assign(ADAPTIVE_LEARNING_RATES, {SUCCESS: bestFoundParams.adaptiveSuccessRate, FAILURE: bestFoundParams.adaptiveFailureRate, MIN_INFLUENCE: bestFoundParams.minAdaptiveInfluence, MAX_INFLUENCE: bestFoundParams.maxAdaptiveInfluence});
                    initializeAdvancedSettingsUI(); saveState();
                    dom.optimizationStatus.textContent = 'Best parameters applied and saved!';
                    handleStrategyChange();
                }
            }
        });
        dom.imageUpload.addEventListener('change', handleImageUpload);
        dom.videoUpload.addEventListener('change', handleVideoUpload);
        dom.loadParametersInput.addEventListener('change', loadParametersFromFile);
        [dom.number1, dom.number2].forEach(input => input.addEventListener('keydown', e => { if (e.key === 'Enter') handleCalculation(); }));
        dom.historyInfoToggle.addEventListener('click', e => { e.stopPropagation(); dom.historyInfoDropdown.classList.toggle('hidden'); });
        document.addEventListener('click', e => { if (dom.historyInfoDropdown && !dom.historyInfoDropdown.contains(e.target) && !dom.historyInfoToggle.contains(e.target)) dom.historyInfoDropdown.classList.add('hidden'); });
        Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => {
            const toggleId = key.replace('use', '').charAt(0).toLowerCase() + key.slice(4) + 'Toggle';
            if(dom[toggleId]) dom[toggleId].addEventListener('change', e => { window[key] = e.target.checked; saveState(); handleStrategyChange(); });
        });
        dom.pocketDistanceToggle.addEventListener('change', e => { usePocketDistance = e.target.checked; saveState(); renderHistory(); });
        dom.advancedCalculationsToggle.addEventListener('change', e => { useAdvancedCalculations = e.target.checked; updateActivePredictionTypes(); saveState(); handleStrategyChange(); });
        dom.dynamicTerminalNeighbourCountToggle.addEventListener('change', e => { useDynamicTerminalNeighbourCount = e.target.checked; saveState(); handleStrategyChange(); });

        // --- APP INITIALIZATION ---
        aiWorker = new Worker('aiWorker.js');
        optimizationWorker = new Worker('optimizationWorker.js');
        optimizationWorker.onmessage = (event) => {
            const { type, payload } = event.data;
            switch (type) {
                case 'progress':
                    dom.optimizationStatus.innerHTML = `Evolving... Gen: <strong>${payload.generation}/${payload.maxGenerations}</strong><br>Variations: <strong>${payload.processedCount}</strong><br>Best W/L: <strong>${payload.bestFitness}</strong>`;
                    bestFoundParams = payload.bestIndividual;
                    break;
                case 'complete':
                    dom.optimizationStatus.textContent = 'Optimization finished!';
                    dom.optimizationResult.classList.remove('hidden');
                    dom.bestFitnessResult.textContent = payload.bestFitness;
                    dom.bestParamsResult.textContent = JSON.stringify(payload.bestIndividual, null, 2);
                    bestFoundParams = payload.bestIndividual;
                    toggleParameterSliders(true);
                    dom.startOptimizationButton.disabled = false;
                    dom.stopOptimizationButton.disabled = true;
                    break;
                case 'stopped':
                    dom.optimizationStatus.textContent = 'Optimization stopped by user.';
                    toggleParameterSliders(true);
                    dom.startOptimizationButton.disabled = false;
                    dom.stopOptimizationButton.disabled = true;
                    break;
            }
        };
        aiWorker.onmessage = (event) => {
            const { type, message, payload } = event.data;
            switch (type) {
                case 'status':
                    dom.aiModelStatus.textContent = message;
                    isAiReady = message.includes('Ready!');
                    break;
                case 'saveScaler':
                    localStorage.setItem('roulette-ml-scaler', payload);
                    break;
            }
        };
        const savedScaler = localStorage.getItem('roulette-ml-scaler');
        aiWorker.postMessage({ type: 'init', payload: { allPredictionTypes: clonablePredictionTypes, terminalMapping: terminalMapping, rouletteWheel: [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32], scaler: savedScaler, historicalStreakData: calculateTrendStats().streakData } });
        
        loadState();
        runAllAnalyses();
        renderHistory();
        drawRouletteWheel();
    } catch (error) {
        if (DEBUG_MODE) console.error('Error during DOMContentLoaded setup:', error);
        document.body.innerHTML = `<div class="card p-8 text-center text-red-600 font-bold text-xl"><p>An critical error occurred during application startup.</p><p>Please check the browser's developer console (F12) for details.</p><p>Error: ${error.message}</p></div>`;
    }
});

// Helper getters to manage scope issues. These will be defined globally once.
function getFullPredictionTypes() {
    return [
        { id: 'diffMinus', label: 'Minus', displayLabel: 'Minus Group', colorClass: 'bg-amber-500', textColor: '#d97706', calculateBase: (n1, n2) => Math.abs(n2 - n1) - 1 },
        { id: 'diffResult', label: 'Result', displayLabel: 'Result Group', colorClass: 'bg-blue-500', textColor: '#2563eb', calculateBase: (n1, n2) => Math.abs(n2 - n1) },
        { id: 'diffPlus', label: 'Plus', displayLabel: 'Plus Group', colorClass: 'bg-red-500', textColor: '#dc2626', calculateBase: (n1, n2) => Math.abs(n2 - n1) + 1 },
        { id: 'sumMinus', label: 'Sum (-1)', displayLabel: '+ and -1', colorClass: 'bg-sumMinus', textColor: '#8b5cf6', calculateBase: (n1, n2) => (n1 + n2) - 1 },
        { id: 'sumResult', label: 'Sum Result', displayLabel: '+', colorClass: 'bg-sumResult', textColor: '#10b981', calculateBase: (n1, n2) => (n1 + n2) },
        { id: 'sumPlus', label: 'Sum (+1)', displayLabel: '+ and +1', colorClass: 'bg-sumPlus', textColor: '#f43f5e', calculateBase: (n1, n2) => (n1 + n2) + 1 }
    ];
}

function getActivePredictionTypes() {
    const allTypes = getFullPredictionTypes();
    if (useAdvancedCalculations) {
        return allTypes;
    }
    return allTypes.filter(type => type.id.startsWith('diff'));
}

    </script>
    </body>
    </html>

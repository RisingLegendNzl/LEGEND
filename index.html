<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Terminal Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0,0,0,0.06);
        }
        .form-input {
            border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;
            font-size: 1rem; width: 100%; transition: border-color 0.3s ease;
        }
        .form-input:focus { outline: none; border-color: #4f46e5; }
        .btn {
            font-weight: 600; padding: 12px 20px; border-radius: 8px;
            transition: all 0.2s ease; border: 2px solid transparent; cursor: pointer;
        }
        .btn:disabled { background-color: #e5e7eb; color: #6b7280; cursor: not-allowed; }
        .btn-primary { background-color: #4f46e5; color: #ffffff; }
        .btn-primary:hover:not(:disabled) { background-color: #4338ca; transform: translateY(-1px); }
        .btn-secondary { background-color: #eef2ff; color: #4f46e5; }
        .btn-secondary:hover:not(:disabled) { background-color: #e0e7ff; }
        .btn-danger { background-color: #fee2e2; color: #dc2626; }
        .btn-danger:hover { background-color: #fecaca; }
        
        .history-list, .analysis-list { max-height: 350px; overflow-y: auto; padding-right: 8px; }
        .history-item {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
            padding: 12px 20px; /* Adjusted padding for more space */
            border-radius: 88px;
            position: relative; /* Added for badge positioning */
            flex-wrap: wrap; /* Allow content to wrap if needed */
        }
        .history-item.is-success { background-color: #f0fdf4; border-color: #22c55e; }
        .history-item.is-fail { background-color: #fef2f2; border-color: #ef4444; }

        .state-badge {
            font-size: 0.75rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 6px;
            color: white;
            position: absolute;
            top: -10px;
            left: 50%; /* Position its left edge at 50% of parent's width */
            transform: translateX(-50%); /* Shift it back by half its own width to truly center */
            z-index: 10; /* Ensure it's on top of other elements */
            white-space: nowrap;
        }
        /* Dynamic background colors based on prediction type ID */
        .bg-amber-500 { background-color: #f59e0b; } /* Orange/Amber for Minus Group */
        .bg-blue-500 { background-color: #3b82f6; } /* Blue for Result Group */
        .bg-red-500 { background-color: #ef4444; } /* Red for Plus Group */
        .bg-sumMinus { background-color: #8b5cf6; } /* Purple */
        .bg-sumResult { background-color: #10b981; } /* Emerald */
        .bg-sumPlus { background-color: #f43f5e; } /* Rose */

        .status-box {
            width: 24px; height: 24px; border-radius: 6px;
            transition: all 0.2s ease;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
        }
        .status-box svg { width: 16px; height: 16px; stroke-width: 2.5; color: #ffffff; }
        
        .success-box { border: 2px solid #dcfce7; background-color: #f0fdf4; }
        .is-success .success-box { background-color: #22c55e; border-color: #16a34a; }

        .fail-box { border: 2px solid #fee2e2; background-color: #fef2f2; }
        .is-fail .fail-box { background-color: #ef4444; border-color: #dc2626; }

        .delete-btn {
            width: 32px; height: 32px; border-radius: 8px; cursor: pointer;
            transition: all 0.2s ease; flex-shrink: 0; display: flex;
            align-items: center; justify-content: center;
            border: 2px solid #e5e7eb; background-color: #fff;
        }
        .delete-btn svg { color: #9ca3af; width: 20px; height: 20px; stroke-width: 2; }
        .delete-btn:hover { background-color: #f3f4f6; border-color: #d1d5db;}
        
        .swap-btn {
            height: 40px; width: 40px;
            background-color: #fff;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; color: #9ca3af;
        }
        .swap-btn:hover { color: #4f46e5; border-color: #c7d2fe; transform: rotate(180deg); }

        .result-display { border-radius: 12px; background-color: #f8fafc; padding: 16px; }
        
        /* Toggle Switch styles */
        .toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            width: 100%;
            padding: 0.5rem 0;
        }
        .toggle-checkbox {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }
        .toggle-switch {
            width: 52px;
            height: 32px;
            background-color: #e5e7eb;
            border-radius: 9999px;
            position: relative;
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0;
        }
        .toggle-knob {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 28px;
            height: 28px;
            background-color: white;
            border-radius: 9999px;
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .toggle-checkbox:checked + .toggle-switch {
            background-color: #4f46e5;
        }
        .toggle-checkbox:checked + .toggle-switch .toggle-knob {
            transform: translateX(20px);
        }
        
        /* Strategy Guide Dropdown */
        .strategy-guide-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding-top 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            padding-top: 0;
            padding-bottom: 0;
            border-top: 1px solid transparent;
        }
        .strategy-guide-content.open {
            max-height: 1000px; /* Increased for more content */
            margin-top: 1rem;
            padding-top: 1rem;
            border-color: #e5e7eb;
            overflow-y: auto;
        }
        .strategy-guide-content h4 { font-weight: 600; color: #374151; margin-top: 0.5rem; }
        .strategy-guide-content p { color: #6b7280; font-size: 0.875rem; }

        /* Sliders and Numeric Inputs */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        .slider-group label {
            flex-basis: 120px; /* Fixed width for labels */
            font-size: 0.875rem;
            color: #4b5563;
        }
        .slider-group input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
        .slider-group input[type="number"] {
            width: 70px; /* Fixed width for number input */
            padding: 0.5rem;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.875rem;
            text-align: center;
        }


        /* Roulette Wheel Styles */
        #rouletteWheelContainer {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }
        #rouletteWheel {
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            background-color: #f8fafc;
        }
        .wheel-number-circle.red { fill: #ef4444; stroke: #b91c1c; }
        .wheel-number-circle.black { fill: #1f2937; stroke: #111827; }
        .wheel-number-circle.green { fill: #22c55e; stroke: #16a34a; }

        .wheel-number-text {
            font-size: 8px; /* Adjusted for better fit */
            font-weight: 600;
            fill: white;
            pointer-events: none; /* Allows click through to circle */
        }

        /* Highlighting for current calculation */
        .wheel-number-circle.highlight-diffMinus { stroke: #f59e0b; stroke-width: 3px; } /* Orange */
        .wheel-number-circle.highlight-diffResult { stroke: #3b82f6; stroke-width: 3px; } /* Blue */
        .wheel-number-circle.highlight-diffPlus { stroke: #ef4444; stroke-width: 3px; } /* Red */
        .wheel-number-circle.highlight-sumMinus { stroke: #8b5cf6; stroke-width: 3px; } /* Purple */
        .wheel-number-circle.highlight-sumResult { stroke: #10b981; stroke-width: 3px; } /* Emerald */
        .wheel-number-circle.highlight-sumPlus { stroke: #f43f5e; stroke-width: 3px; } /* Rose */
        .wheel-number-circle.highlight-winning { stroke: #10b981; stroke-width: 4px; } /* Stronger green for winning number */

        .roulette-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #4b5563;
        }
        .roulette-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
        .bg-roulette-red { background-color: #ef4444; }
        .bg-roulette-black { background-color: #1f2937; }
        .bg-roulette-green { background-color: #22c55e; }
        .bg-highlight-diffMinus { background-color: #f59e0b; }
        .bg-highlight-diffResult { background-color: #3b82f6; }
        .bg-highlight-diffPlus { background-color: #ef4444; }
        .bg-highlight-sumMinus { background-color: #8b5cf6; }
        .bg-highlight-sumResult { background-color: #10b981; }
        .bg-highlight-sumPlus { background-color: #f43f5e; }
        .text-pink-400 { color: #f472b6; } /* Light pink for distance numbers */

        /* Added text color classes for specific groups */
        .text-purple-700 { color: #7e22ce; } /* For base number highlight */

        /* Pattern Alert styles */
        .pattern-alert {
            background-color: #eef2ff;
            border: 2px solid #c7d2fe;
            color: #4338ca;
            border-radius: 8px;
            padding: 12px;
            margin-top: 1rem;
            font-size: 0.875rem;
            text-align: center;
            font-weight: 500;
        }

        /* Explainable AI Details Section */
        .ai-details-section {
            background-color: #f0f4f8; /* Light blue-gray background */
            border-top: 1px solid transparent; /* Start with transparent border */
            border-radius: 0 0 8px 8px;
            padding: 0 16px; /* Start with 0 padding-top/bottom */
            margin-top: 0; /* Start with 0 margin-top */
            font-size: 0.8rem;
            color: #4a5568;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            display: block; /* Show when open */ 
            transition: max-height 0.5s ease-out, padding 0.5s ease-out, margin-top 0.5s ease-out, border-top-color 0.5s ease-out, opacity 0.3s ease-out, visibility 0.3s ease-out;
        }
        .ai-details-section.open {
            max-height: 500px; /* Adjust as needed for content */
            padding: 12px 16px; /* Apply padding when open */
            margin-top: 8px; /* Apply margin when open */
            border-top-color: #e2e8f0; /* Apply border color when open */
            opacity: 1;
            visibility: visible;
            display: block; /* Show when open */
        }
        .ai-details-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .ai-details-section li {
            margin-bottom: 4px;
        }
        .ai-details-toggle {
            display: block;
            width: fit-content;
            margin-top: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #4f46e5;
            cursor: pointer;
            text-decoration: underline;
            transition: color 0.2s ease;
        }
        .ai-details-toggle:hover {
            color: #4338ca;
        }
    </style>
</head>
<body class="text-gray-800 py-10 px-4">
    <div class="w-full max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        <main class="space-y-8">
            <div class="card p-8 space-y-6">
                <div class="text-center">
                    <h1 class="text-3xl font-bold text-gray-800">Automated Terminal Calculator</h1>
                </div>

                <div class="flex items-center space-x-4">
                    <div class="flex-1 space-y-2">
                        <label for="number1" class="text-sm font-medium text-gray-700">Number to Subtract</label>
                        <input type="number" id="number1" class="form-input">
                    </div>
                    <button id="swapButton" class="swap-btn mt-8 flex-shrink-0" aria-label="Swap numbers">
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16V4m0 12l-4-4m4 4l4-4m6 8v-12m0 12l-4-4m4 4l4-4" />
                        </svg>
                    </button>
                    <div class="flex-1 space-y-2">
                        <label for="number2" class="text-sm font-medium text-gray-700">Subtract From</label>
                        <input type="number" id="number2" class="form-input">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <button id="clearInputsButton" class="w-full btn btn-secondary">Clear Inputs</button>
                    <button id="calculateButton" class="w-full btn btn-primary">Calculate</button>
                </div>
                
                <div id="resultDisplay" class="hidden"></div>
            </div>

            <div class="card p-8 space-y-4" id="historySection">
                <div class="flex justify-between items-center">
                    <div class="flex items-center gap-4">
                        <h2 class="text-xl font-bold text-gray-700">History</h2>
                        <div class="text-sm font-medium">
                            <span class="text-green-600 font-semibold">Wins: <span id="winCount">0</span></span> |
                            <span class="text-red-600 font-semibold">Losses: <span id="lossCount">0</span></span>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                         <button id="historyInfoToggle" class="bg-gray-100 text-gray-600 hover:bg-gray-200 px-3 py-1 rounded-md text-sm font-semibold transition-colors duration-200">
                            Info
                            <svg class="inline-block w-4 h-4 ml-1 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                        <div id="historyInfoDropdown" class="absolute right-0 mt-2 w-72 bg-white border border-gray-200 rounded-lg shadow-lg p-4 text-sm text-gray-700 z-10 hidden">
                            <p class="font-semibold mb-2">History Log Insights:</p>
                            <ul class="list-disc pl-4 space-y-1">
                                <li><strong class="text-gray-800">Reco: [Group] (Hit)</strong> <span class="text-xs text-gray-500">(Group Color Badge):</span> Your recommended group was successful.</li>
                                <li><strong class="text-gray-800">Reco: [Group] (Missed), Hit: [Other Group(s)]</strong> <span class="text-xs text-gray-500">(Red Badge):</span> Your recommended group missed, but another group happened to hit.</li>
                                <li><strong class="text-gray-800">Reco: [Group] (Missed)</strong> <span class="text-xs text-gray-500">(Group Color Badge/Red Cross):</span> Your recommended group and all other active groups missed.</li>
                                <li><strong class="text-green-600">Green checkmark:</strong> Overall, at least one active group hit.</li>
                                <li><strong class="text-red-600">Red cross:</strong> Overall, no active group hit.</li>
                            </ul>
                        </div>
                        <button id="clearHistoryButton" class="btn btn-danger text-sm py-2 px-3">Clear History</button>
                    </div>
                </div>
                <ul id="historyList" class="history-list space-y-3"></ul>
            </div>
        </main>
        
        <aside class="space-y-8">
            <div class="card p-8">
                <div id="rouletteWheelSection">
                    <h2 class="text-xl font-bold text-gray-700">Roulette Wheel Visualizer</h2>
                    <div id="rouletteWheelContainer"></div>
                    <div class="mt-4 grid grid-cols-2 gap-2 text-sm" id="rouletteLegend">
                    </div>
                </div>
            </div>
            
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Video Analysis Engine</h2>
                <p class="text-sm text-gray-500">Upload a short video of the spin result to detect the winning number.</p>
                
                <div id="videoUploadContainer" class="mt-2">
                    <input type="file" id="videoUpload" class="hidden" accept="video/*">
                    <label for="videoUpload" id="videoUploadLabel" class="w-full text-center btn btn-secondary cursor-pointer">Upload Spin Video</label>
                </div>

                <div id="videoControlsContainer" class="mt-2 grid grid-cols-2 gap-2 hidden">
                    <button id="clearVideoButton" class="w-full btn btn-danger">Clear Video</button>
                    <button id="analyzeVideoButton" class="w-full btn btn-primary">Analyze Video</button>
                </div>

                <p id="videoStatus" class="text-sm text-center text-gray-600 h-4 mt-2"></p>
                <video id="videoPlayer" class="w-full h-48 object-cover rounded-lg hidden bg-gray-900" controls></video>
                <canvas id="frameCanvas" class="w-full h-48 object-cover rounded-lg hidden mt-2"></canvas>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Global Analysis</h2>
                <p class="text-sm text-gray-500">Recalculate all analysis panels based on the current strategy settings. This is useful for back-testing strategies on the entire loaded history.</p>
                <button id="recalculateAnalysisButton" class="w-full btn btn-secondary mt-2">Recalculate All Analyses</button>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Data Input & Training</h2>
                <p class="text-sm text-gray-500">Paste numbers separated by space, comma, or newline, from newest to oldest.</p>
                <textarea id="historicalNumbersInput" class="form-input" rows="4" placeholder="e.g., 10, 5, 22, ... (10 is newest)"></textarea>
                <div class="mt-2">
                    <input type="file" id="imageUpload" class="hidden" accept="image/*">
                    <label for="imageUpload" id="imageUploadLabel" class="w-full text-center btn btn-secondary cursor-pointer">Upload Image of History</label>
                </div>
                <button id="analyzeHistoricalDataButton" class="w-full btn btn-primary mt-2">Analyze Historical Data & Train AI</button>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Status & Analysis</h2>
                <p class="text-sm text-gray-500">Monitor the AI's current status and performance.</p>
                <p id="historicalAnalysisMessage" class="text-sm text-gray-600 mt-2 text-center"></p>
                <div id="aiModelStatus" class="text-sm text-gray-700 text-center font-medium"></div>
            </div>

            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">AI Parameter Optimizer</h2>
                <p class="text-sm text-gray-500">
                    Use a genetic algorithm to evolve the best possible strategy parameters.
                    The AI will run simulations to find the settings that produce the highest win/loss ratio.
                    <strong>This is a computationally intensive process.</strong>
                </p>
            
                <div class="grid grid-cols-2 gap-4">
                    <button id="startOptimizationButton" class="w-full btn btn-primary">Start Optimization</button>
                    <button id="stopOptimizationButton" class="w-full btn btn-danger" disabled>Stop Optimization</button>
                </div>
            
                <div id="optimizationStatus" class="text-center text-sm font-medium text-gray-700 mt-2 h-10">
                    </div>
            
                <div id="optimizationResult" class="hidden mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
                    <h4 class="font-bold text-indigo-800">Optimization Complete!</h4>
                    <p class="text-sm text-indigo-700">Best W/L Ratio Found: <strong id="bestFitnessResult"></strong></p>
                    <pre id="bestParamsResult" class="text-xs bg-white p-2 rounded-md mt-2 overflow-x-auto"></pre>
                    <button id="applyBestParamsButton" class="w-full btn btn-secondary mt-3">Apply These Settings</button>
                </div>
            </div>

            <div class="card p-8">
                <div id="presetStrategyGuideHeader" onclick="toggleGuide('presetStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-gray-700">Strategy Presets</h2>
                    <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                </div>
                <div id="presetStrategyGuideContent" class="strategy-guide-content">
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-bold text-gray-800">Highest Win Rate</h4>
                            <p>Enables `Neighbour Score Weighting` and `Use Proximity Boost` while disabling all others. This mode plays every round and had the highest overall win rate (51.5%) based on simulations.</p>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Balanced & Safe</h4>
                            <p>Enables all strategies in the disciplined 'Strict' mode. This provides a good win rate (48.9%) on the spins it plays by waiting for trend confirmation.</p>
                        </div>
                            <div>
                            <h4 class="font-bold text-gray-800">Aggressive Signals</h4>
                            <p>Enables all strategies and turns on `Less Strict Mode`. This uses the 'safe' logic but is much more likely to find and flag `(High Confidence)` opportunities.</p>
                        </div>
                    </div>
                </div>
                <div class="pt-4 grid grid-cols-1 md:grid-cols-3 gap-2">
                    <button id="setHighestWinRatePreset" class="btn btn-secondary text-sm">Highest Win Rate</button>
                    <button id="setBalancedSafePreset" class="btn btn-secondary text-sm">Balanced & Safe</button>
                    <button id="setAggressiveSignalsPreset" class="btn btn-secondary text-sm">Aggressive</button>
                </div>
            </div>

            <div class="card p-8">
                    <div id="baseStrategyGuideHeader" onclick="toggleGuide('baseStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                        <h2 class="text-xl font-bold text-gray-700">Base Strategies</h2>
                        <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                    </div>
                    <div id="baseStrategyGuideContent" class="strategy-guide-content">
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-bold text-gray-800">Wait for Trend Confirmation</h4>
                                <p>When enabled, the app becomes more cautious. It will only issue a "Play" recommendation if its top-ranked state is the same as the state that won on the previous successful spin. Otherwise, it will advise you to wait for a stronger signal.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Use Neighbour Score Weighting</h4>
                                <p>When enabled, this makes the recommendation smarter. It boosts the score of states whose "hit zones" contain numbers that are currently "hot" in the "Neighbour Analysis" panel.</p>
                            </div>
                                <div>
                                <h4 class="font-bold text-gray-800">Use Proximity Boost</h4>
                                <p>When enabled, this gives a score boost to the state whose hit zone is physically closest on the roulette wheel to the last number spun, based on the theory of wheel "gravity".</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Show Pocket Distance in History</h4>
                                <p>When enabled, each successful history entry will display the shortest "pocket distance" from the winning number to the successful prediction's hit zone.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Prioritize Lowest Pocket Distance</h4>
                                <p>When enabled, the recommendation will prioritize the group(s) whose hit zone is closest (pocket distance 0 or 1) to the last confirmed winning number. This overrides other strategy weightings if a very close distance is found.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Enable Advanced Calculation Methods</h4>
                                <p>When enabled, the app will track and recommend based on additional calculation methods (Sum, Sum +/- 1) alongside the standard Difference-based methods. All active methods will compete for the primary recommendation and have their performance tracked.</p>
                            </div>
                        </div>
                    </div>
                    <div class="pt-2 divide-y divide-gray-200">
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Wait for Trend Confirmation</span>
                            <input type="checkbox" id="trendConfirmationToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Use Neighbour Score Weighting</span>
                            <input type="checkbox" id="weightedZoneToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Use Proximity Boost</span>
                            <input type="checkbox" id="proximityBoostToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Show Pocket Distance</span>
                            <input type="checkbox" id="pocketDistanceToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Prioritize Lowest Pocket Distance</span>
                            <input type="checkbox" id="lowestPocketDistanceToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Enable Advanced Calculations</span>
                            <input type="checkbox" id="advancedCalculationsToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                    </div>
            </div>
                <div class="card p-8">
                    <div id="advancedStrategyGuideHeader" onclick="toggleGuide('advancedStrategyGuideContent')" class="flex justify-between items-center cursor-pointer">
                        <h2 class="text-xl font-bold text-gray-700">Advanced Strategies</h2>
                        <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">What do these do?</button>
                    </div>
                    <div id="advancedStrategyGuideContent" class="strategy-guide-content">
                        <div class="space-y-4">
                            <div>
                                <h4 class="font-bold text-gray-800">Dynamic Best Strategy</h4>
                                <p>When enabled, the app will automatically analyze its recent history to identify which single prediction method is performing the best and advise playing it.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Adaptive Play Signals</h4>
                                <p>Provides more nuanced betting advice ('Strong Play', 'Wait', 'Avoid Now') based on the quality and risk of the current signal.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Table Change Warnings</h4>
                                <p>Provides warnings when a previously strong pattern seems to be breaking, helping you avoid potential losing streaks.</p>
                            </div>
                                <div>
                                <h4 class="font-bold text-gray-800">Due for a Hit (Contrarian)</h4>
                                <p>When enabled, this strategy looks for a state that has been performing well below its historical average and recommends it, betting on a return to the mean.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Neighbour Focus</h4>
                                <p>When enabled, this strategy refines the main recommendation by highlighting the "hottest" numbers from the Neighbour Analysis that fall within the recommended group's hit zone.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Less Strict Mode</h4>
                                <p>When enabled, this relaxes the conditions for a "(High Confidence)" recommendation. It will be shown if the top state has a very high hit rate (over 60%) or a long winning streak (3 or more), removing the need for trend confirmation.</p>
                            </div>
                            <div>
                                <h4 class="font-bold text-gray-800">Dynamic Terminal Neighbour Count</h4>
                                <p>When enabled, the "hit zone" for a prediction will dynamically adjust its terminal neighbour count based on whether the winning number is a direct hit or a neighbor. If the winning number is the base number or a direct terminal, the terminal neighbour count will be 0. Otherwise, it will use the standard terminal neighbour count (3 or 1).</p>
                            </div>
                        </div>
                    </div>
                    <div class="pt-2 divide-y divide-gray-200">
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Dynamic Best Strategy</span>
                            <input type="checkbox" id="dynamicStrategyToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Adaptive Play Signals</span>
                            <input type="checkbox" id="adaptivePlayToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Table Change Warnings</span>
                            <input type="checkbox" id="tableChangeWarningsToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Due for a Hit (Contrarian)</span>
                            <input type="checkbox" id="dueForHitToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Neighbour Focus</span>
                            <input type="checkbox" id="neighbourFocusToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Less Strict Mode</span>
                            <input type="checkbox" id="lessStrictModeToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                        <label class="toggle-label">
                            <span class="font-medium text-gray-700">Dynamic Terminal Neighbour Count</span>
                            <input type="checkbox" id="dynamicTerminalNeighbourCountToggle" class="toggle-checkbox">
                            <div class="toggle-switch"><div class="toggle-knob"></div></div>
                        </label>
                    </div>
            </div>

            <div class="card p-8">
                <div id="advancedSettingsHeader" onclick="toggleGuide('advancedSettingsContent')" class="flex justify-between items-center cursor-pointer">
                    <h2 class="text-xl font-bold text-gray-700">Advanced Settings</h2>
                    <button class="text-indigo-600 hover:text-indigo-800 font-semibold text-sm">Adjust Parameters</button>
                </div>
                <div id="advancedSettingsContent" class="strategy-guide-content space-y-6">
                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Strategy Learning Rates</h3>
                        <div class="space-y-3" id="strategyLearningRatesSliders">
                            </div>
                    </div>

                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Pattern & Trigger Thresholds</h3>
                        <div class="space-y-3" id="patternThresholdsSliders">
                            </div>
                    </div>

                    <div class="space-y-3">
                        <h3 class="text-lg font-semibold text-gray-700">Adaptive Influence Learning</h3>
                        <div class="space-y-3" id="adaptiveInfluenceSliders">
                            </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4 border-t border-gray-200">
                        <button id="resetParametersButton" class="btn btn-secondary">Reset to Defaults</button>
                        <button id="saveParametersButton" class="btn btn-secondary">Save Parameters to File</button>
                        <input type="file" id="loadParametersInput" class="hidden" accept=".json">
                        <label for="loadParametersInput" id="loadParametersLabel" class="w-full text-center btn btn-secondary cursor-pointer">Load Parameters from File</label>
                    </div>

                    <p id="parameterStatusMessage" class="text-sm text-center text-gray-600 mt-2 h-4"></p>
                </div>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Board State Analysis</h2>
                <div id="boardStateAnalysis" class="space-y-2"></div>
                <p id="boardStateConclusion" class="text-center font-bold pt-2"></p>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Dynamic Strategy Weights</h2>
                <div id="strategyWeightsDisplay" class="space-y-3">
                    </div>
            </div>
            <div class="card p-8 space-y-4">
                <h2 class="text-xl font-bold text-gray-700">Neighbour Analysis</h2>
                <p class="text-sm text-gray-500">Analysis of neighboring numbers based on successes.</p>
                <ul id="analysisList" class="analysis-list space-y-1"></ul>
            </div>
        </aside>
    </div>

    <script>
        // IMPORTANT: This key is exposed and should not be used in production without securing it.
        const GOOGLE_API_KEY = "YOUR_API_KEY_HERE";

        const DEBUG_MODE = true; // Set to 'true' for debugging, 'false' for production.

        // --- Core Strategy Configuration (Tunable via Advanced Settings) ---
        // These are declared with `let` so their values can be modified by the UI sliders.
        let STRATEGY_CONFIG = {
            learningRate_success: 0.35, 
            learningRate_failure: 0.05, 
            maxWeight: 6.0,             
            minWeight: 0.03,            
            decayFactor: 0.88,          
            patternMinAttempts: 5,      
            patternSuccessThreshold: 68,
            triggerMinAttempts: 5,      
            triggerSuccessThreshold: 63,
        };

        // --- Adaptive Learning Rates for Factor Influences (Tunable via Advanced Settings) ---
        // Declared with `let` for UI tunability.
        let ADAPTIVE_LEARNING_RATES = {
            SUCCESS: 0.15, 
            FAILURE: 0.1,  
            MIN_INFLUENCE: 0.2, 
            MAX_INFLUENCE: 2.5,
        };

        // --- DEFAULT PARAMETERS (For Resetting and Initial Load) ---
        // This object holds the truly initial/default values for all tunable parameters (STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES, and Toggles).
        // It's used by the "Reset to Defaults" button and as a fallback during initial setup/loading.
        const DEFAULT_PARAMETERS = {
            STRATEGY_CONFIG: {
                learningRate_success: 0.30, 
                learningRate_failure: 0.03, 
                maxWeight: 5.0,             
                minWeight: 0.03,            
                decayFactor: 0.88,          
                patternMinAttempts: 5,      
                patternSuccessThreshold: 68,
                triggerMinAttempts: 5,      
                triggerSuccessThreshold: 63,
            },
            ADAPTIVE_LEARNING_RATES: {
                SUCCESS: 0.15, 
                FAILURE: 0.1,  
                MIN_INFLUENCE: 0.2, 
                MAX_INFLUENCE: 2.5,
            },
            TOGGLES: { // Store initial toggle states here too, for completeness
                useTrendConfirmation: false,
                useWeightedZone: true,
                useProximityBoost: true,
                usePocketDistance: false,
                useLowestPocketDistance: false,
                useAdvancedCalculations: false,
                useDynamicStrategy: false,
                useAdaptivePlay: false,
                useTableChangeWarnings: false,
                useDueForHit: false,
                useNeighbourFocus: false,
                useLessStrict: false,
                useDynamicTerminalNeighbourCount: false,
            }
        };

        // TensorFlow.js specific configurations (constants for main thread's use)
        const TRAINING_MIN_HISTORY = 10; // Minimum history items needed to train the model
        const AI_SEQUENCE_LENGTH = 5; // Matches SEQUENCE_LENGTH in aiWorker.js

        // Web Worker instance - this will handle all TF.js operations
        let aiWorker;

        // NEW: Web Worker for parameter optimization
        let optimizationWorker;
        let bestFoundParams = null; // To store the result from the optimizer

        let history = [];
        let confirmedWinsLog = [];
        let isAiReady = false;
        let strategyStates = {
            weightedZone: { weight: 1.0, name: 'Neighbour Weighting' },
            proximityBoost: { weight: 1.0, name: 'Proximity Boost' }
        };
        let patternMemory = {};
        let adaptiveFactorInfluences = {
            'Hit Rate': 1.0,
            'Streak': 1.0,
            'Proximity to Last Spin': 1.0,
            'Hot Zone Weighting': 1.0,
            'High AI Confidence': 1.0,
            'Statistical Trends': 1.0
        };
        let currentVideoURL = null;

        // --- GLOBAL TOGGLE STATES (Managed by UI and Load/Save) ---
        // These are declared with `let` to allow assignment from loaded state or presets.
        // They are initialized from DEFAULT_PARAMETERS for clarity.
        let useTrendConfirmation = DEFAULT_PARAMETERS.TOGGLES.useTrendConfirmation;
        let useWeightedZone = DEFAULT_PARAMETERS.TOGGLES.useWeightedZone;
        let useProximityBoost = DEFAULT_PARAMETERS.TOGGLES.useProximityBoost;
        let usePocketDistance = DEFAULT_PARAMETERS.TOGGLES.usePocketDistance;
        let useLowestPocketDistance = DEFAULT_PARAMETERS.TOGGLES.useLowestPocketDistance;
        let useAdvancedCalculations = DEFAULT_PARAMETERS.TOGGLES.useAdvancedCalculations;
        let useDynamicStrategy = DEFAULT_PARAMETERS.TOGGLES.useDynamicStrategy;
        let useAdaptivePlay = DEFAULT_PARAMETERS.TOGGLES.useAdaptivePlay;
        let useTableChangeWarnings = DEFAULT_PARAMETERS.TOGGLES.useTableChangeWarnings;
        let useDueForHit = DEFAULT_PARAMETERS.TOGGLES.useDueForHit;
        let useNeighbourFocus = DEFAULT_PARAMETERS.TOGGLES.useNeighbourFocus;
        let useLessStrict = DEFAULT_PARAMETERS.TOGGLES.useLessStrict;
        let useDynamicTerminalNeighbourCount = DEFAULT_PARAMETERS.TOGGLES.useDynamicTerminalNeighbourCount;


        function toggleGuide(contentId) {
            const content = document.getElementById(contentId);
            if (content) {
                content.classList.toggle('open');
            }
        }

        // --- CORE ROULETTE DATA AND HELPERS (GLOBAL CONSTANTS FOR ALL FUNCTIONS) ---
        // These are outside any specific function so they are universally available.
        const terminalMapping = {
            0: [4, 6], 1: [8], 2: [7, 9], 3: [8], 4: [11], 5: [12, 10], 6: [11], 7: [14, 2],
            8: [15, 13, 3, 1], 9: [14, 2], 10: [17, 5], 11: [18, 16, 6, 4], 12: [17, 5],
            13: [20, 23], 14: [9, 21, 7, 19], 15: [8, 20], 16: [11], 17: [12, 24, 10, 22],
            18: [11, 23], 19: [14, 26], 20: [13, 25, 15, 27], 21: [14, 26], 22: [17, 29],
            23: [18, 30, 16, 28], 24: [17, 29], 25: [20, 32], 26: [19, 31, 33, 21],
            27: [20, 32], 28: [23, 35], 29: [22, 34, 24, 36], 30: [23, 35], 31: [26],
            32: [25, 27], 33: [26], 34: [29], 35: [28, 30], 36: [29]
        };
        const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];

        // Prediction types - these include functions, so they are not directly serializable to worker
        // but their IDs/labels can be passed.
        const allPredictionTypes = [
            { id: 'diffMinus', label: 'Minus', displayLabel: 'Minus Group', colorClass: 'bg-amber-500', calculateBase: (n1, n2) => Math.abs(n2 - n1) - 1 },
            { id: 'diffResult', label: 'Result', displayLabel: 'Result Group', colorClass: 'bg-blue-500', textColor: '#2563eb', calculateBase: (n1, n2) => Math.abs(n2 - n1) },
            { id: 'diffPlus', label: 'Plus', displayLabel: 'Plus Group', colorClass: 'bg-red-500', textColor: '#dc2626', calculateBase: (n1, n2) => Math.abs(n2 - n1) + 1 },
            { id: 'sumMinus', label: 'Sum (-1)', displayLabel: '+ and -1', colorClass: 'bg-sumMinus', textColor: '#8b5cf6', calculateBase: (n1, n2) => (n1 + n2) - 1 },
            { id: 'sumResult', label: 'Sum Result', displayLabel: '+', colorClass: 'bg-sumResult', textColor: '#10b981', calculateBase: (n1, n2) => (n1 + n2) },
            { id: 'sumPlus', label: 'Sum (+1)', displayLabel: '+ and +1', colorClass: 'bg-sumPlus', textColor: '#f43f5e', calculateBase: (n1, n2) => (n1 + n2) + 1 }
        ];
        // Create a version of allPredictionTypes without functions for the worker
        const clonablePredictionTypes = allPredictionTypes.map(type => ({
            id: type.id,
            label: type.label,
            displayLabel: type.displayLabel,
            colorClass: type.colorClass,
            textColor: type.textColor
        }));

        let activePredictionTypes = []; // This will be set based on useAdvancedCalculations

        // Pure helper functions - access global constants directly
        function getNeighbours(number, count) {
            const index = rouletteWheel.indexOf(number);
            if (index === -1) return [];
            const neighbours = new Set();
            const wheelSize = rouletteWheel.length;
            for (let i = 1; i <= count; i++) {
                neighbours.add(rouletteWheel[(index - i + wheelSize) % wheelSize]);
                neighbours.add(rouletteWheel[(index + i) % wheelSize]);
            }
            return Array.from(neighbours);
        }
        
        function calculatePocketDistance(num1, num2) {
            const index1 = rouletteWheel.indexOf(num1);
            const index2 = rouletteWheel.indexOf(num2);
            if (index1 === -1 || index2 === -1) {
                return Infinity;
            }
            const directDistance = Math.abs(index1 - index2);
            const wrapAroundDistance = rouletteWheel.length - directDistance;
            return Math.min(directDistance, wrapAroundDistance);
        }

        // Refactored to use global constants, accepts necessary toggles/configs as args
        function getHitZone(baseNumber, terminals, winningNumber = null, useDynamicTerminalNeighbourCountBool) {
            if (baseNumber < 0 || baseNumber > 36) return [];
            const hitZone = new Set([baseNumber]);
            const numTerminals = terminals ? terminals.length : 0;

            let baseNeighbourCount = (numTerminals === 1) ? 3 : (numTerminals >= 2) ? 1 : 0;
            if (baseNeighbourCount > 0) getNeighbours(baseNumber, baseNeighbourCount).forEach(n => hitZone.add(n));

            let terminalNeighbourCount;
            if (useDynamicTerminalNeighbourCountBool && winningNumber !== null) {
                if (baseNumber === winningNumber || (terminals && terminals.includes(winningNumber))) {
                    terminalNeighbourCount = 0;
                } else {
                    terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
                }
            } else {
                terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
            }

            if (terminals && terminals.length > 0) {
                terminals.forEach(t => {
                    hitZone.add(t);
                    if (terminalNeighbourCount > 0) getNeighbours(t, terminalNeighbourCount).forEach(n => hitZone.add(n));
                });
            }
            return Array.from(hitZone);
        }

        function getRouletteNumberColor(number) {
            if (number === 0) return 'green';
            const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
            if (redNumbers.includes(number)) return 'red';
            return 'black';
        }

        /**
         * Evaluates a history item against a winning number to determine its status (success/fail),
         * which prediction types hit, and the pocket distance of the hit.
         * @param {object} historyItem - The history item to evaluate.
         * @param {number} winningNumber - The actual winning number for this spin.
         * @param {object} current_STRATEGY_CONFIG - The strategy config to use.
         * @param {boolean} useDynamicTerminalNeighbourCountBool - The toggle state to use.
         */
        function evaluateCalculationStatus(historyItem, winningNumber, current_STRATEGY_CONFIG, useDynamicTerminalNeighbourCountBool) {
            historyItem.winningNumber = winningNumber;
            historyItem.hitTypes = [];
            historyItem.typeSuccessStatus = {};
            let minPocketDistance = Infinity;

            // Use the active prediction types for the evaluation
            activePredictionTypes.forEach(type => {
                const baseNum = type.calculateBase(historyItem.num1, historyItem.num2);
                if (baseNum < 0 || baseNum > 36) {
                    historyItem.typeSuccessStatus[type.id] = false;
                    return;
                }

                const terminals = terminalMapping?.[baseNum] || [];
                const hitZone = getHitZone(baseNum, terminals, winningNumber, useDynamicTerminalNeighbourCountBool);
                
                if (hitZone.includes(winningNumber)) {
                    historyItem.hitTypes.push(type.id);
                    historyItem.typeSuccessStatus[type.id] = true;

                    // Calculate pocket distance for this successful hit
                    let currentMinDist = Infinity;
                    hitZone.forEach(zoneNum => {
                        const dist = calculatePocketDistance(zoneNum, winningNumber);
                        if (dist < currentMinDist) {
                            currentMinDist = dist;
                        }
                    });
                    if (currentMinDist < minPocketDistance) {
                        minPocketDistance = currentMinDist;
                    }
                } else {
                    historyItem.typeSuccessStatus[type.id] = false;
                }
            });

            historyItem.status = historyItem.hitTypes.length > 0 ? 'success' : 'fail';
            historyItem.pocketDistance = minPocketDistance !== Infinity ? minPocketDistance : null;
            
            // Specifically set the pocket distance for the recommended group if it hit
            if (historyItem.recommendedGroupId && historyItem.hitTypes.includes(historyItem.recommendedGroupId)) {
                historyItem.recommendedGroupPocketDistance = historyItem.pocketDistance;
            } else {
                historyItem.recommendedGroupPocketDistance = null;
            }
        }

        /**
         * Iterates through the history to label items with a specific failure mode.
         * This is primarily for providing more detailed data to the AI model.
         * @param {Array} sortedHistory - Chronologically sorted history array.
         * @param {object} current_STRATEGY_CONFIG - The strategy config to use.
         * @param {boolean} useDynamicTerminalNeighbourCountBool - The toggle state to use.
         */
        function labelHistoryFailures(sortedHistory, current_STRATEGY_CONFIG, useDynamicTerminalNeighbourCountBool) {
            let lastSuccessfulType = null;
            sortedHistory.forEach((item, index) => {
                if (item.status === 'pending' || item.winningNumber === null) return;

                // Default to 'none' if it was a success
                if (item.status === 'success') {
                    item.failureMode = 'none';
                    if (item.recommendedGroupId && item.hitTypes.includes(item.recommendedGroupId)) {
                        lastSuccessfulType = item.recommendedGroupId;
                    }
                    return;
                }

                // If it was a failure
                if (item.recommendedGroupId) {
                    if (lastSuccessfulType && item.recommendedGroupId === lastSuccessfulType) {
                        // The model recommended the previously successful type, but it failed.
                        item.failureMode = 'streakBreak';
                    } else if (lastSuccessfulType && item.recommendedGroupId !== lastSuccessfulType) {
                        // The model switched strategies, and the new one failed.
                        item.failureMode = 'sectionShift';
                    } else {
                        // A normal loss without a clear pattern break.
                        item.failureMode = 'normalLoss';
                    }
                } else {
                    item.failureMode = 'normalLoss'; // Default failure mode
                }
            });
        }

        async function runAllAnalyses() {
            if (DEBUG_MODE) {
                console.log('Running all analyses...');
            }
            saveState();

            const trendStats = calculateTrendStats(history, STRATEGY_CONFIG, activePredictionTypes);
            const boardStats = getBoardStateStats(history, STRATEGY_CONFIG);
            const neighbourScores = runNeighbourAnalysis(true, history, STRATEGY_CONFIG, useDynamicTerminalNeighbourCount);
            
            renderStrategyWeights();

            dom.boardStateAnalysis.innerHTML = '';
            for(const typeId in boardStats) {
                const type = allPredictionTypes.find(t => t.id === typeId);
                if (!type) continue;
                
                const stats = boardStats[typeId];
                const hitRate = stats.total > 0 ? (stats.success / stats.total * 100) : 0;
                
                dom.boardStateAnalysis.innerHTML += `
                    <div class="text-sm">
                        <span class="font-semibold" style="color:${type.textColor || '#1f2937'};">${type.displayLabel}:</span>
                        <span class="float-right font-medium">${hitRate.toFixed(2)}%</span>
                    </div>
                `;
            }

            const num1Val = parseInt(dom.number1.value, 10);
            const num2Val = parseInt(dom.number2.value, 10);
            const lastWinningNumber = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length - 1] : null;

            if (!isNaN(num1Val) && !isNaN(num2Val)) {
                const difference = Math.abs(num2Val - num1Val);
                const recommendation = getRecommendation({
                    trendStats,
                    boardStats,
                    neighbourScores,
                    diff: difference,
                    inputNum1: num1Val, inputNum2: num2Val,
                    isForWeightUpdate: false, aiPredictionData: null,
                    currentAdaptiveInfluences: adaptiveFactorInfluences,
                    lastWinningNumber, useProximityBoostBool: useProximityBoost, useWeightedZoneBool: useWeightedZone,
                    useNeighbourFocusBool: useNeighbourFocus, isAiReadyBool: isAiReady,
                    useTrendConfirmationBool: useTrendConfirmation, current_STRATEGY_CONFIG: STRATEGY_CONFIG,
                    current_ADAPTIVE_LEARNING_RATES: ADAPTIVE_LEARNING_RATES, currentHistoryForTrend: history
                });

                dom.resultDisplay.innerHTML = recommendation.html;
                dom.resultDisplay.classList.remove('hidden');

                if (history.length > 0 && history[history.length - 1].status === 'pending') {
                    history[history.length - 1].recommendedGroupId = recommendation.bestCandidate ? recommendation.bestCandidate.type.id : null;
                    history[history.length - 1].recommendationDetails = recommendation.details;
                }
            }
        }

        function saveState() {
            localStorage.setItem('terminalCalculatorState', JSON.stringify({
                history, confirmedWinsLog,
                useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance, useLowestPocketDistance, useAdvancedCalculations,
                useNeighbourFocus, useDueForHit, useLessStrict,
                useDynamicStrategy, useAdaptivePlay, useTableChangeWarnings,
                useDynamicTerminalNeighbourCount,
                strategyStates,
                patternMemory,
                adaptiveFactorInfluences,
                TOGGLES: { // Save current toggle states for persistence
                    useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance, useLowestPocketDistance,
                    useAdvancedCalculations, useDynamicStrategy, useAdaptivePlay, useTableChangeWarnings,
                    useDueForHit, useNeighbourFocus, useLessStrict, useDynamicTerminalNeighbourCount
                },
                STRATEGY_CONFIG, // Save current parameter values
                ADAPTIVE_LEARNING_RATES,
            }));
        }

        function renderStrategyWeights() {
            if (DEBUG_MODE) {
                console.log('Rendering strategy weights...');
            }
            if (!dom.strategyWeightsDisplay) return;
            dom.strategyWeightsDisplay.innerHTML = '';

            for (const key in strategyStates) {
                const strategy = strategyStates[key];
                const weightPercentage = ((strategy.weight - STRATEGY_CONFIG.minWeight) / (STRATEGY_CONFIG.maxWeight - STRATEGY_CONFIG.minWeight)) * 100;

                const weightColor = strategy.weight > 1.0 ? 'bg-green-500' : strategy.weight < 1.0 ? 'bg-red-500' : 'bg-blue-500';

                dom.strategyWeightsDisplay.innerHTML += `
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <span class="font-medium text-sm text-gray-700">${strategy.name}</span>
                            <span class="font-semibold text-sm text-gray-600">${strategy.weight.toFixed(2)}x</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div class="${weightColor} h-2.5 rounded-full transition-all duration-300" style="width: ${Math.max(0, Math.min(100, weightPercentage))}%"></div>
                        </div>
                    </div>
                `;
            }
        }

        // --- MAIN APP LOGIC & UI FUNCTIONS ---

        function updateAllTogglesUI() {
            dom.trendConfirmationToggle.checked = useTrendConfirmation;
            dom.weightedZoneToggle.checked = useWeightedZone;
            dom.proximityBoostToggle.checked = useProximityBoost;
            dom.pocketDistanceToggle.checked = usePocketDistance;
            dom.lowestPocketDistanceToggle.checked = useLowestPocketDistance;
            dom.advancedCalculationsToggle.checked = useAdvancedCalculations;
            dom.dynamicStrategyToggle.checked = useDynamicStrategy;
            dom.adaptivePlayToggle.checked = useAdaptivePlay;
            dom.tableChangeWarningsToggle.checked = useTableChangeWarnings;
            dom.dueForHitToggle.checked = useDueForHit;
            dom.neighbourFocusToggle.checked = useNeighbourFocus;
            dom.lessStrictModeToggle.checked = useLessStrict;
            dom.dynamicTerminalNeighbourCountToggle.checked = useDynamicTerminalNeighbourCount;
        }

        function updateActivePredictionTypes() {
            if (useAdvancedCalculations) {
                activePredictionTypes = allPredictionTypes;
            } else {
                activePredictionTypes = allPredictionTypes.filter(type =>
                    type.id === 'diffMinus' || type.id === 'diffResult' || type.id === 'diffPlus'
                );
            }
            updateRouletteLegend();
            // Update worker config as well
            if (aiWorker) {
                aiWorker.postMessage({ 
                    type: 'update_config', 
                    payload: { 
                        allPredictionTypes: clonablePredictionTypes, 
                        terminalMapping: terminalMapping,
                        rouletteWheel: rouletteWheel,
                        history: history,
                        currentNum1: parseInt(dom.number1.value, 10),
                        currentNum2: parseInt(dom.number2.value, 10),
                        currentDifference: Math.abs(parseInt(dom.number2.value, 10) - parseInt(dom.number1.value, 10)),
                        lastWinningNumber: confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length -1] : null,
                    } 
                });
            }
        }

        function updateRouletteLegend() {
            dom.rouletteLegend.innerHTML = `
                <div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-green"></div> Green (0)</div>
                <div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-red"></div> Red Numbers</div>
                <div class="roulette-legend-item"><div class="roulette-legend-color bg-roulette-black"></div> Black Numbers</div>
            `;
            activePredictionTypes.forEach(type => {
                dom.rouletteLegend.innerHTML += `
                    <div class="roulette-legend-item"><div class="roulette-legend-color ${type.colorClass}"></div> ${type.displayLabel}</div>
                `;
            });
            dom.rouletteLegend.innerHTML += `
                <div class="roulette-legend-item"><div class="roulette-legend-color bg-highlight-winning"></div> Winning Number</div>
            `;
        }

        function drawRouletteWheel(currentDiff = null, lastWinningNumber = null) {
            dom.rouletteWheelContainer.innerHTML = '';
            const svgWidth = dom.rouletteWheelContainer.clientWidth || 300;
            const svgHeight = svgWidth;
            const radius = (svgWidth / 2) * 0.8;
            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;
            const numberRadius = 15;

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("id", "rouletteWheel");
            svg.setAttribute("width", svgWidth);
            svg.setAttribute("height", svgHeight);
            svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);

            const outerCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            outerCircle.setAttribute("cx", centerX);
            outerCircle.setAttribute("cy", centerY);
            outerCircle.setAttribute("r", radius + numberRadius + 5);
            outerCircle.setAttribute("fill", "none");
            outerCircle.setAttribute("stroke", "#e2e8f0");
            outerCircle.setAttribute("stroke-width", "2");
            svg.appendChild(outerCircle);

            const highlightedNumbers = new Set();
            const hitZoneClasses = {};

            if (currentDiff !== null && !isNaN(currentDiff)) {
                const num1 = parseInt(dom.number1.value, 10);
                const num2 = parseInt(dom.number2.value, 10);

                activePredictionTypes.forEach(type => {
                    const baseNum = type.calculateBase(num1, num2);
                    if (baseNum < 0 || baseNum > 36) return;
                    
                    const terminals = terminalMapping?.[baseNum] || [];
                    // Use global useDynamicTerminalNeighbourCount
                    const hitZone = getHitZone(baseNum, terminals, lastWinningNumber, useDynamicTerminalNeighbourCount); 
                    hitZone.forEach(num => {
                        highlightedNumbers.add(num);
                        if (!hitZoneClasses[num]) {
                            hitZoneClasses[num] = `highlight-${type.id}`;
                        }
                    });
                });
            }

            rouletteWheel.forEach((number, index) => {
                const angle = (index / rouletteWheel.length) * 2 * Math.PI - (Math.PI / 2);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const numberColor = getRouletteNumberColor(number);
                let strokeClass = '';

                if (lastWinningNumber !== null && number === lastWinningNumber) {
                    strokeClass = 'highlight-winning';
                } else if (highlightedNumbers.has(number)) {
                    strokeClass = hitZoneClasses[number];
                }

                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", numberRadius);
                circle.setAttribute("class", `wheel-number-circle ${numberColor} ${strokeClass}`);
                svg.appendChild(circle);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", x);
                text.setAttribute("y", y + 3);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("class", "wheel-number-text");
                text.textContent = number;
                svg.appendChild(text);
            });

            dom.rouletteWheelContainer.appendChild(svg);
        }

        function updateWinLossCounter() {
            let wins = 0;
            let losses = 0;

            history.forEach(item => {
                if (item.recommendedGroupId) {
                    if (item.hitTypes && item.hitTypes.includes(item.recommendedGroupId)) {
                        wins++;
                    } else {
                        if (item.winningNumber !== null) { // Only count as loss if there was a winning number
                            losses++;
                        }
                    }
                }
            });

            dom.winCount.textContent = wins;
            dom.lossCount.textContent = losses;
        }

        function renderHistory() {
            updateWinLossCounter(); 

            dom.historyList.innerHTML = `<li class="text-center text-gray-500 py-4">No calculations yet.</li>`;
            if (history.length === 0) return;
            dom.historyList.innerHTML = '';
            history.slice().sort((a, b) => b.id - a.id).forEach(item => {
                const li = document.createElement('li');
                li.className = 'history-item relative';
                if (item.status === 'success') li.classList.add('is-success');
                if (item.status === 'fail') li.classList.add('is-fail');
                
                let stateBadgeContent;
                let stateBadgeClass = 'bg-gray-400';

                if (item.status === 'pending') {
                    stateBadgeContent = 'Pending';
                    stateBadgeClass = 'bg-gray-400';
                } else if (item.recommendedGroupId !== null) { 
                    const recommendedType = allPredictionTypes.find(type => type.id === item.recommendedGroupId);
                    const recommendedLabel = recommendedType?.displayLabel || 'Unknown Group'; 
                    const recommendedColorClass = recommendedType?.colorClass || 'bg-gray-400';

                    const recommendedHit = item.hitTypes.includes(item.recommendedGroupId);
                    const otherGroupsHit = item.hitTypes.length > 0 && !recommendedHit;

                    if (recommendedHit) {
                        stateBadgeContent = `Reco: ${recommendedLabel} (Hit)`;
                        stateBadgeClass = recommendedColorClass;
                    } else if (otherGroupsHit) {
                        const otherHitLabels = item.hitTypes
                            .filter(id => id !== item.recommendedGroupId)
                            .map(id => allPredictionTypes.find(type => type.id === id)?.displayLabel || id);
                        stateBadgeContent = `Reco: ${recommendedLabel} (Missed), Hit: ${otherHitLabels.join(' & ')}`;
                        stateBadgeClass = 'bg-red-500';
                    } else {
                        stateBadgeContent = `Reco: ${recommendedLabel} (Missed)`;
                        stateBadgeClass = recommendedColorClass;
                    }
                } else { 
                    if (item.status === 'success') {
                        if (item.hitTypes && item.hitTypes.length > 0) {
                            stateBadgeContent = `Success (No Reco)`; 
                            stateBadgeClass = 'bg-green-600';
                        } else {
                            stateBadgeContent = 'Success (No Reco)'; 
                            stateBadgeClass = 'bg-green-600';
                        }
                    } else { 
                        stateBadgeContent = 'Failed (No Reco)'; 
                        stateBadgeClass = 'bg-red-500';
                    }
                }

                let pocketDistanceDisplay = '';
                if (usePocketDistance && item.status === 'success' && item.pocketDistance !== undefined && item.pocketDistance !== null) {
                    pocketDistanceDisplay = ` (<span class="text-pink-400">Dist: ${item.pocketDistance}</span>)`;
                }

                const recommendedHit = item.recommendedGroupId && item.hitTypes.includes(item.recommendedGroupId);
                const showFailIcon = (item.recommendedGroupId && !recommendedHit) || item.status === 'fail';
                const showSuccessIcon = item.status === 'success' && recommendedHit;

                let aiDetailsHtml = '';
                const showAiDetailsToggle = item.recommendedGroupId; 
                if (showAiDetailsToggle && item.recommendationDetails) {
                    const details = item.recommendationDetails;
                    aiDetailsHtml = `
                        <div class="ai-details-toggle" data-target="ai-details-${item.id}">Show Details</div>
                        <div id="ai-details-${item.id}" class="ai-details-section">
                            <ul>
                                ${details.primaryDrivingFactor ? `<li><strong>Reason: ${details.primaryDrivingFactor}</strong> (Influence: ${details.adaptiveInfluenceUsed?.toFixed(2) || '1.00'})</li>` : ''}
                                <li>Base Score: ${details.baseScore.toFixed(2)}</li>
                                ${details.confluenceBonus ? `<li>Confluence Bonus: ${details.confluenceBonus.toFixed(2)}x</li>` : ''}
                                <li>Hit Rate: ${details.hitRate.toFixed(2)}%</li>
                                <li>Avg Trend: ${details.avgTrend.toFixed(1)}</li>
                                <li>Proximity: ${details.predictiveDistance !== Infinity ? details.predictiveDistance : 'N/A'} (Boost: ${details.proximityBoostApplied ? 'Yes' : 'No'})</li>
                                <li>Neighbour Weighting: ${details.weightedZoneBoostApplied ? 'Yes' : 'No'}</li>
                                <li>Pattern Boost: ${details.patternBoostApplied ? `Yes (${details.patternBoostMultiplier.toFixed(2)}x)` : 'No'}</li>
                                <li>AI Probability: ${details.mlProbability !== null ? (details.mlProbability * 100).toFixed(1) + '%' : 'N/A'} (Boost: ${details.mlBoostApplied ? 'Yes' : 'No'})</li>
                                <li>AI Low Pocket Boost: ${details.aiLowPocketBoostApplied ? 'Yes' : 'No'}</li>
                                <li>Final Score: ${details.finalScore.toFixed(2)}</li>
                            </ul>
                        </div>
                    `;
                }

                li.innerHTML = `
                    ${stateBadgeContent ? `<div class="state-badge ${stateBadgeClass}">${stateBadgeContent}</div>` : ''}
                    <p>${item.num2} - ${item.num1} = <strong class="text-lg">${item.difference}</strong>${pocketDistanceDisplay}</p>
                    <div class="flex items-center space-x-2">
                        <div class="status-box fail-box" style="display:${showFailIcon ? 'flex' : 'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></div>
                        <div class="status-box success-box" style="display:${showSuccessIcon ? 'flex' : 'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg></div>
                        <button class="delete-btn" data-id="${item.id}" aria-label="Delete item"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m-1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button>
                    </div>
                    ${aiDetailsHtml}
                    `;
                dom.historyList.appendChild(li);
            });

            document.querySelectorAll('.ai-details-toggle').forEach(toggle => {
                toggle.onclick = (e) => {
                    const targetId = toggle.dataset.target;
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.classList.toggle('open');
                        toggle.textContent = targetElement.classList.contains('open') ? 'Hide Details' : 'Show Details';
                    }
                };
            });
        }

        // --- Core Simulation and Analysis Functions ---
        // These now directly use global variables where appropriate, or accept necessary parameters.

        // Refactored to accept relevant configs/toggles explicitly
        function calculateTrendStats(currentHistory, current_STRATEGY_CONFIG, activeTypesArr) {
            const sortedHistory = [...currentHistory].sort((a, b) => a.id - b.id);
            const streakData = {};
            const currentStreaks = {};
            const totalOccurrences = {};
            const successfulOccurrences = {};
            let lastSuccessState = [];

            activeTypesArr.forEach(type => {
                streakData[type.id] = [];
                currentStreaks[type.id] = 0;
                totalOccurrences[type.id] = 0;
                successfulOccurrences[type.id] = 0;
            });

            sortedHistory.forEach((item, i) => {
                if (item.status === 'pending') return;

                const weight = Math.pow(current_STRATEGY_CONFIG.decayFactor, sortedHistory.length - 1 - i);

                activeTypesArr.forEach(type => {
                    const predictionTypeDefinition = allPredictionTypes.find(t => t.id === type.id);
                    if (!predictionTypeDefinition) return;
                    const baseNum = predictionTypeDefinition.calculateBase(item.num1, item.num2);

                    if (baseNum >= 0 && baseNum <= 36) {
                        totalOccurrences[type.id] += weight;
                    }
                    
                    const wasSuccessful = item.typeSuccessStatus && item.typeSuccessStatus[type.id];
                    
                    if (wasSuccessful) {
                        currentStreaks[type.id]++;
                        successfulOccurrences[type.id] += weight;
                    } else {
                        if (currentStreaks[type.id] > 0) {
                            streakData[type.id].push(currentStreaks[type.id]);
                        }
                        currentStreaks[type.id] = 0;
                    }
                });
                
                if (item.status === 'success') {
                    lastSuccessState = item.hitTypes; 
                }
            });

            const averages = {};
            const averageHitRates = {};
            activeTypesArr.forEach(type => {
                const allStreaksForType = [...streakData[type.id]];
                if (currentStreaks[type.id] > 0) {
                    allStreaksForType.push(currentStreaks[type.id]);
                }
                averages[type.id] = (allStreaksForType.length > 0) ?
                    (allStreaksForType.reduce((a, b) => a + b, 0) / allStreaksForType.length).toFixed(1) : '0.0';
                
                averageHitRates[type.id] = totalOccurrences[type.id] > 0 ?
                    (successfulOccurrences[type.id] / totalOccurrences[type.id] * 100) : 0;
            });

            return { averages, currentStreaks, lastSuccessState, averageHitRates, totalOccurrences, successfulOccurrences, streakData }; 
        }

        // Refactored to accept relevant configs/toggles explicitly
        function getBoardStateStats(simulatedHistory, current_STRATEGY_CONFIG) {
            const stats = {};
            activePredictionTypes.forEach(type => {
                stats[type.id] = { success: 0, total: 0 };
            });

            simulatedHistory.forEach((item, i) => {
                const weight = Math.pow(current_STRATEGY_CONFIG.decayFactor, simulatedHistory.length - 1 - i);
                activePredictionTypes.forEach(type => {
                    const predictionTypeDefinition = allPredictionTypes.find(t => t.id === type.id);
                    if (!predictionTypeDefinition) return;
                    const baseNum = predictionTypeDefinition.calculateBase(item.num1, item.num2);

                    if (baseNum >= 0 && baseNum <= 36) {
                        stats[type.id].total += weight;
                    }
                });
                if (item.status === 'success') {
                    item.hitTypes.forEach(typeId => {
                        if (stats[typeId]) stats[typeId].success += weight;
                    });
                }
            });
            return stats;
        }
        
        // Refactored to accept relevant configs/toggles explicitly
        function runNeighbourAnalysis(render = true, simulatedHistory, current_STRATEGY_CONFIG, current_useDynamicTerminalNeighbourCount) {
            if (DEBUG_MODE) {
                console.log('Running neighbour analysis...');
            }
            const analysis = {};
            for (let i = 0; i <= 36; i++) analysis[i] = { success: 0 };
            simulatedHistory.forEach((item, i) => {
                if (item.status !== 'success') return;
                
                const weight = Math.pow(current_STRATEGY_CONFIG.decayFactor, simulatedHistory.length - 1 - i);

                item.hitTypes.forEach(typeId => {
                    const type = allPredictionTypes.find(t => t.id === typeId);
                    if (!type) return;

                    const predictionTypeDefinition = allPredictionTypes.find(t => t.id === type.id);
                    if (!predictionTypeDefinition) return;
                    const baseNum = predictionTypeDefinition.calculateBase(item.num1, item.num2);

                    if (baseNum < 0 || baseNum > 36) return;

                    const terminals = terminalMapping[baseNum] || [];
                    const points = {};
                    let baseNeighbourCount = (terminals.length === 1) ? 3 : (terminals.length >= 2) ? 1 : 0;
                    if (baseNeighbourCount > 0) getNeighbours(baseNum, baseNeighbourCount).forEach(n => { points[n] = (points[n] || 0) + 1; });
                    
                    const numTerminals = terminals ? terminals.length : 0;
                    let terminalNeighbourCount;

                    if (current_useDynamicTerminalNeighbourCount && item.winningNumber !== null) {
                        if (baseNum === item.winningNumber || terminals.includes(item.winningNumber)) {
                            terminalNeighbourCount = 0;
                        } else {
                            terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
                        }
                    } else {
                        terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
                    }

                    if(terminalNeighbourCount > 0) terminals.forEach(t => getNeighbours(t, terminalNeighbourCount).forEach(n => { points[n] = (points[n] || 0) + 1; }));
                    for (const num in points) {
                        if (analysis[num]) analysis[num].success += points[num] * weight;
                    }
                });
            });
            if(render) {
                dom.analysisList.innerHTML = `<li class="text-center text-gray-500 py-4">Not enough data. Confirm winning numbers.</li>`;
                const sortedAnalysis = Object.entries(analysis).map(([num, scores]) => ({ num: parseInt(num), score: scores.success })).sort((a, b) => b.score - a.score);
                if (sortedAnalysis.every(a => a.score === 0) && history.filter(item => item.status === 'success').length === 0) return;
                dom.analysisList.innerHTML = '';
                sortedAnalysis.forEach(({num, score}) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<div class="grid grid-cols-2 items-center p-2 rounded-md ${score > 0 ? 'bg-green-50' : ''}"><div class="font-bold text-lg text-center text-indigo-600">${num}</div><div class="font-semibold text-center ${score > 0 ? 'text-green-700' : 'text-gray-600'}">Score: ${score.toFixed(2)}</div></div>`;
                    dom.analysisList.appendChild(li);
                });
            }
            return analysis;
        }

        // Refactored to accept all relevant parameters (for optimizer and main app)
        function getRecommendation(context) {
            // Destructure the context object for easier access to variables
            const {
                trendStats, boardStats, neighbourScores,
                diff, inputNum1, inputNum2,
                isForWeightUpdate = false, aiPredictionData = null,
                currentAdaptiveInfluences, lastWinningNumber,
                useProximityBoostBool, useWeightedZoneBool, useNeighbourFocusBool,
                isAiReadyBool, useTrendConfirmationBool,
                current_STRATEGY_CONFIG, current_ADAPTIVE_LEARNING_RATES, currentHistoryForTrend
            } = context;

            // ---> ADD THIS DEBUGGING BLOCK START <---
            if (DEBUG_MODE) {
                console.log('--- Debugging getRecommendation Data ---');
                console.log('trendStats:', JSON.parse(JSON.stringify(trendStats)));
                console.log('boardStats:', JSON.parse(JSON.stringify(boardStats)));
                console.log('neighbourScores:', neighbourScores ? 'Exists' : 'UNDEFINED');
                console.log('currentAdaptiveInfluences:', currentAdaptiveInfluences ? 'Exists' : 'UNDEFINED');
            }
            // ---> ADD THIS DEBUGGING BLOCK END <---

            const currentNum1 = inputNum1;
            const currentNum2 = inputNum2;

            let candidates = activePredictionTypes.map(type => {
                const details = {
                    baseScore: 0,
                    hitRate: (boardStats[type.id]?.total > 0 ? (boardStats[type.id]?.success / boardStats[type.id]?.total * 100) : 0),
                    avgTrend: parseFloat(trendStats.averages[type.id]) || 0,
                    currentStreak: trendStats.currentStreaks[type.id] || 0,
                    predictiveDistance: Infinity, 
                    proximityBoostApplied: false,
                    weightedZoneBoostApplied: false,
                    patternBoostApplied: false,
                    patternBoostMultiplier: 1,
                    mlProbability: (aiPredictionData && aiPredictionData.groups && aiPredictionData.groups[type.id] !== undefined) ? aiPredictionData.groups[type.id] : 0, 
                    mlBoostApplied: false,
                    aiLowPocketBoostApplied: false,
                    finalScore: 0,
                    primaryDrivingFactor: "N/A",
                    adaptiveInfluenceUsed: 1.0,
                    confluenceBonus: 1.0,
                    reason: [],
                    individualScores: {} 
                };

                const predictionTypeDefinition = allPredictionTypes.find(t => t.id === type.id);
                if (!predictionTypeDefinition) return null;
                const baseNum = predictionTypeDefinition.calculateBase(currentNum1, currentNum2);
                if (baseNum < 0 || baseNum > 36) return null;

                const terminals = terminalMapping?.[baseNum] || [];
                // Use the passed useDynamicTerminalNeighbourCount for internal hitZone calculation
                const hitZone = getHitZone(baseNum, terminals, lastWinningNumber, useDynamicTerminalNeighbourCount); 

                // --- Calculate Raw Score Components ---
                let rawScore = 0;

                // 1. Base Score from Hit Rate
                const rawHitRatePoints = Math.max(0, details.hitRate - 40) * 0.5;
                rawScore += rawHitRatePoints;
                details.individualScores['Hit Rate'] = rawHitRatePoints;
                if (rawHitRatePoints > 1) details.reason.push(`Hit Rate`);

                // 2. Momentum Score from Current Streak
                const rawStreakPoints = Math.min(15, details.currentStreak * 5);
                rawScore += rawStreakPoints;
                details.individualScores['Streak'] = rawStreakPoints;
                if (rawStreakPoints > 0) details.reason.push(`Streak`);
                
                // 3. Proximity Score (IF TOGGLED)
                if (useProximityBoostBool && lastWinningNumber !== null) { 
                    for (const zoneNum of hitZone) {
                        const dist = calculatePocketDistance(zoneNum, lastWinningNumber); 
                        if (dist < details.predictiveDistance) details.predictiveDistance = dist;
                    }
                    details.proximityBoostApplied = details.predictiveDistance <= 5;
                    if (details.proximityBoostApplied) {
                        const rawProximityPoints = (5 - details.predictiveDistance) * 2;
                        rawScore += rawProximityPoints;
                        details.individualScores['Proximity to Last Spin'] = rawProximityPoints;
                        details.reason.push(`Proximity`);
                    }
                }

                // 4. Neighbour Score (IF TOGGLED)
                if (useWeightedZoneBool) { 
                    const neighbourWeightedScore = hitZone.reduce((sum, num) => sum + (neighbourScores[num]?.success || 0), 0);
                    const rawNeighbourPoints = Math.min(10, neighbourWeightedScore * 0.5);
                    rawScore += rawNeighbourPoints;
                    details.individualScores['Hot Zone Weighting'] = rawNeighbourPoints;
                    details.weightedZoneBoostApplied = rawNeighbourPoints > 0;
                    if (details.weightedZoneBoostApplied) details.reason.push(`Neighbours`);
                }

                // 5. AI Confidence Score
                if (isAiReadyBool && details.mlProbability > 0) { 
                    const rawAiPoints = details.mlProbability * 25; 
                    rawScore += rawAiPoints;
                    details.individualScores['High AI Confidence'] = rawAiPoints;
                    details.mlBoostApplied = rawAiPoints > 0;
                    if (rawAiPoints > 5) details.reason.push(`AI Conf`);
                }
                
                // --- APPLY ADAPTIVE INFLUENCES ---
                let finalCalculatedScore = 0;
                let mostInfluentialFactor = "N/A";
                let highestInfluencedScore = 0;

                for (const factorName in currentAdaptiveInfluences) {
                    const influence = currentAdaptiveInfluences[factorName];
                    let factorScore = details.individualScores[factorName] || 0; 

                    const influencedScore = factorScore * influence;
                    finalCalculatedScore += influencedScore; 

                    if (influencedScore > highestInfluencedScore) {
                        highestInfluencedScore = influencedScore;
                        mostInfluentialFactor = factorName;
                    }
                }

                if (mostInfluentialFactor === "N/A" && details.reason.length > 0) {
                    mostInfluentialFactor = details.reason[0]; 
                } else if (mostInfluentialFactor === "N/A") {
                    mostInfluentialFactor = "Statistical Trends"; 
                }

                details.finalScore = finalCalculatedScore; 
                details.baseScore = rawHitRatePoints + rawStreakPoints; 
                details.primaryDrivingFactor = mostInfluentialFactor;
                details.adaptiveInfluenceUsed = currentAdaptiveInfluences[mostInfluentialFactor] || 1.0;

                return { type, score: details.finalScore, details }; 
            }).filter(c => c && !isNaN(c.score)); 

            if (candidates.length === 0) {
                return { html: '<span class="text-gray-500">Wait for Signal</span><br><span class="text-xs">Not enough data for a recommendation.</span>', bestCandidate: null, details: null };
            }

            candidates.sort((a, b) => b.score - a.score);
            let bestCandidate = candidates[0];
            
            if (bestCandidate.score <= 0) { 
                return { html: '<span class="text-gray-500">Wait for Signal</span><br><span class="text-xs">No strong recommendations based on current data.</span>', bestCandidate: null, details: null };
            }

            if (isForWeightUpdate) {
                return { bestCandidate };
            }

            let signal = "Wait";
            let signalColor = "text-gray-500";
            let reason = "(Low Confidence)"; 

            // Use current_STRATEGY_CONFIG and current_ADAPTIVE_LEARNING_RATES passed from optimizer OR global ones
            // when defining conditions for play/strong play
            const effectiveStrategyConfig = current_STRATEGY_CONFIG || STRATEGY_CONFIG;
            const effectiveAdaptiveRates = current_ADAPTIVE_LEARNING_RATES || ADAPTIVE_LEARNING_RATES;


            if (bestCandidate.score > 50) { 
                signal = "Strong Play";
                signalColor = "text-green-600";
                reason = `(${bestCandidate.details?.primaryDrivingFactor || 'Unknown Reason'})`; 
            } else if (bestCandidate.score > 20) { 
                signal = "Play";
                signalColor = "text-purple-700";
                reason = `(${bestCandidate.details?.primaryDrivingFactor || 'Unknown Reason'})`; 
            }
            
            // Use useTrendConfirmationBool parameter
            if (useTrendConfirmationBool && trendStats.lastSuccessState.length > 0 && !trendStats.lastSuccessState.includes(bestCandidate.type.id)) {
                    if (DEBUG_MODE) { console.log('DEBUG: Trend confirmation blocking play.'); }
                signal = 'Wait for Signal';
                signalColor = "text-gray-500";
                reason = `(Waiting for ${bestCandidate.type.label} trend confirmation)`;
            } else if (useTrendConfirmationBool && trendStats.lastSuccessState.length === 0 && currentHistoryForTrend.filter(item => item.status === 'success').length > 0) {
                signal = 'Wait for Signal';
                signalColor = "text-gray-500";
                reason = `(No established trend to confirm)`;
            }

            let finalHtml = `<strong class="${signalColor}">${signal}:</strong> Play <strong style="color: ${bestCandidate.type.textColor};">${bestCandidate.type.label}</strong><br><span class="text-xs text-gray-600">Final Score: ${bestCandidate.score.toFixed(2)}</span><br><span class="text-xs text-gray-500">${reason}</span>`;
            if (signal.includes('Wait')) {
                    finalHtml = `<strong class="${signalColor}">${signal}</strong> <br><span class="text-xs text-gray-600">Final Score: ${bestCandidate.score.toFixed(2)}</span><br><span class="text-xs text-gray-500">${reason}</span>`;
            }

            // Use useNeighbourFocusBool parameter
            if (useNeighbourFocusBool && (signal === 'Play' || signal === 'Strong Play')) {
                const baseNum = bestCandidate.type.calculateBase(currentNum1, currentNum2);
                const terminals = terminalMapping?.[baseNum] || [];
                // Use global useDynamicTerminalNeighbourCount
                const hotNumbers = getHitZone(baseNum, terminals, lastWinningNumber, useDynamicTerminalNeighbourCount) 
                    .map(num => ({num, score: neighbourScores[num]?.success || 0 }))
                    .filter(n => n.score > 0) 
                    .sort((a,b) => b.score - a.score)
                    .slice(0,5)
                    .map(n => n.num);

                if (hotNumbers.length > 0) { 
                    finalHtml += `<br><span class="text-xs text-gray-600">Focus on hot neighbours: <strong>${hotNumbers.join(', ')}</strong></span>`;
                }
            }
            
            return { html: finalHtml, bestCandidate, details: bestCandidate.details };
        }


        // Updated for global functions and correct parameter passing
        function runSimulationOnHistory(spinsToProcess, sim_STRATEGY_CONFIG, sim_ADAPTIVE_LEARNING_RATES, sim_Toggles) {
            // Local states for this specific simulation run (important for optimizer)
            const localHistory = [];
            let localConfirmedWinsLog = [];
            const localAdaptiveFactorInfluences = {
                'Hit Rate': 1.0, 'Streak': 1.0, 'Proximity to Last Spin': 1.0,
                'Hot Zone Weighting': 1.0, 'High AI Confidence': 1.0, 'Statistical Trends': 1.0
            };

            const baseTimestamp = Date.now();

            for (let i = 0; i <= spinsToProcess.length - 3; i++) {
                const num1 = spinsToProcess[i];
                const num2 = spinsToProcess[i + 1];
                const winningNumber = spinsToProcess[i + 2]; // The actual outcome for this simulated spin
                const diff = Math.abs(num2 - num1);
                const calcId = baseTimestamp + i;

                // Pass local simulation history, configs, and toggles for correct context
                const trendStatsAtCalc = calculateTrendStats(localHistory, sim_STRATEGY_CONFIG, activePredictionTypes);
                const boardStatsAtCalc = getBoardStateStats(localHistory, sim_STRATEGY_CONFIG);
                const neighbourScoresAtCalc = runNeighbourAnalysis(false, localHistory, sim_STRATEGY_CONFIG, sim_Toggles.useDynamicTerminalNeighbourCount);


                const recommendationAtCalc = getRecommendation({
                    trendStats: trendStatsAtCalc, boardStats: boardStatsAtCalc, neighbourScores: neighbourScoresAtCalc,
                    diff, inputNum1: num1, inputNum2: num2,
                    isForWeightUpdate: false, aiPredictionData: null,
                    currentAdaptiveInfluences: localAdaptiveFactorInfluences,
                    lastWinningNumber: localConfirmedWinsLog.length > 0 ? localConfirmedWinsLog[localConfirmedWinsLog.length - 1] : null,
                    useProximityBoostBool: sim_Toggles.useProximityBoost,
                    useWeightedZoneBool: sim_Toggles.useWeightedZone,
                    useNeighbourFocusBool: sim_Toggles.useNeighbourFocus,
                    isAiReadyBool: false, // isAiReady is false for simulation
                    useTrendConfirmationBool: sim_Toggles.useTrendConfirmation,
                    current_STRATEGY_CONFIG: sim_STRATEGY_CONFIG,
                    current_ADAPTIVE_LEARNING_RATES: sim_ADAPTIVE_LEARNING_RATES,
                    currentHistoryForTrend: localHistory
                });

                const newHistoryItem = {
                    id: calcId, num1: num1, num2: num2, difference: diff,
                    status: 'pending', hitTypes: [], typeSuccessStatus: {},
                    confirmedStreak: 0, pocketDistance: null, winningNumber: winningNumber,
                    recommendedGroupId: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.type.id : null,
                    recommendationDetails: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.details : null
                };

                // Evaluate status using the specific configs/toggles for this simulation
                evaluateCalculationStatus(newHistoryItem, winningNumber, sim_STRATEGY_CONFIG, sim_Toggles.useDynamicTerminalNeighbourCount);
                localHistory.push(newHistoryItem);

                // Update adaptive influences within this simulation's context
                if (newHistoryItem.recommendedGroupId && newHistoryItem.recommendationDetails?.primaryDrivingFactor) {
                    const primaryFactor = newHistoryItem.recommendationDetails.primaryDrivingFactor;
                    if (localAdaptiveFactorInfluences[primaryFactor] === undefined) localAdaptiveFactorInfluences[primaryFactor] = 1.0;
                    if (newHistoryItem.hitTypes.includes(newHistoryItem.recommendedGroupId)) {
                        localAdaptiveFactorInfluences[primaryFactor] = Math.min(sim_ADAPTIVE_LEARNING_RATES.MAX_INFLUENCE, localAdaptiveFactorInfluences[primaryFactor] + sim_ADAPTIVE_LEARNING_RATES.SUCCESS);
                    } else {
                        localAdaptiveFactorInfluences[primaryFactor] = Math.max(sim_ADAPTIVE_LEARNING_RATES.MIN_INFLUENCE, localAdaptiveFactorInfluences[primaryFactor] - sim_ADAPTIVE_LEARNING_RATES.FAILURE);
                    }
                }
                
                // Add to local confirmed wins log for subsequent simulation steps
                if (winningNumber !== null && !localConfirmedWinsLog.includes(winningNumber)) {
                    localConfirmedWinsLog.push(winningNumber);
                }
            }

            // Only update global history when this function is called from the main app's UI/data processing
            if (sim_STRATEGY_CONFIG === STRATEGY_CONFIG) { // This condition means it's the main app's simulation, not optimizer's
                history = localHistory;
                confirmedWinsLog = localHistory.map(item => item.winningNumber).filter(n => n !== null).reverse();
                // Ensure failures are labeled in the global history
                labelHistoryFailures(history.slice().sort((a, b) => a.id - b.id), STRATEGY_CONFIG, useDynamicTerminalNeighbourCount); 
            }

            return localHistory; // Always return the simulated history for analysis purposes
        }

        /**
         * Handles the selection of a video file and updates the UI accordingly.
         * @param {Event} event - The file input change event.
         */
        function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (currentVideoURL) {
                URL.revokeObjectURL(currentVideoURL);
            }
            currentVideoURL = URL.createObjectURL(file);

            dom.videoPlayer.src = currentVideoURL;
            dom.videoPlayer.classList.remove('hidden');
            dom.videoUploadContainer.classList.add('hidden');
            dom.videoControlsContainer.classList.remove('hidden');
            dom.videoStatus.textContent = 'Video loaded. Ready to analyze.';
        }

        /**
         * Placeholder for starting the video analysis process.
         * In a real implementation, this would involve sending frames to OpenCV.js or a vision API.
         */
        function startVideoAnalysis() {
            dom.analyzeVideoButton.disabled = true;
            dom.videoStatus.textContent = 'Analyzing... (Feature in development)';
            
            // In a real implementation, you would:
            // 1. Capture a frame from the video player onto the canvas.
            // 2. Use OpenCV.js to process the image on the canvas (e.g., find contours, threshold).
            // 3. Use OCR (like Tesseract.js) or a call to a cloud service (like Google Cloud Vision)
            //    with the processed image data to detect the number.
            // 4. Once a number is found, you would update a history item and run analysis.
            console.log("Video analysis initiated.");
            
            // Simulate a delay and then re-enable the button
            setTimeout(() => {
                dom.analyzeVideoButton.disabled = false;
                dom.videoStatus.textContent = 'Analysis complete (simulation).';
            }, 2000);
        }

        /**
         * Clears the current video and resets the UI to the upload state.
         */
        function clearVideoState() {
            if (currentVideoURL) {
                URL.revokeObjectURL(currentVideoURL);
                currentVideoURL = null;
            }
            dom.videoPlayer.src = '';
            dom.videoUpload.value = ''; // Clear the file input

            dom.videoPlayer.classList.add('hidden');
            dom.frameCanvas.classList.add('hidden');
            dom.videoControlsContainer.classList.add('hidden');
            dom.videoUploadContainer.classList.remove('hidden');
            dom.videoStatus.textContent = '';
        }

        // Updated for global functions and correct parameter passing
        async function handleHistoricalAnalysis() {
            dom.historicalAnalysisMessage.textContent = 'Processing historical data...';

            const rawInput = dom.historicalNumbersInput.value;
            if (!rawInput.trim()) {
                dom.historicalAnalysisMessage.textContent = 'Please paste historical numbers.';
                return;
            }
            const numbers = rawInput.trim().split(/[\s,]+/).filter(Boolean).map(Number);
            if (numbers.length < 3 || numbers.some(isNaN) || numbers.some(n => n < 0 || n > 36)) {
                dom.historicalAnalysisMessage.textContent = 'Please provide at least 3 valid numbers (0-36).';
                return;
            }

            const historicalSpinsChronological = numbers.slice().reverse();

            runSimulationOnHistory(historicalSpinsChronological, STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES, { 
                useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance,
                useLowestPocketDistance, useAdvancedCalculations, useDynamicStrategy,
                useAdaptivePlay, useTableChangeWarnings, useDueForHit, useNeighbourFocus,
                useLessStrict, useDynamicTerminalNeighbourCount
            });


            dom.historicalAnalysisMessage.textContent = `Successfully processed and simulated ${history.length} historical entries.`;
            runAllAnalyses();
            renderHistory();
            drawRouletteWheel();
            
            const successfulHistoryCount = history.filter(item => item.status === 'success').length;
            if (successfulHistoryCount >= TRAINING_MIN_HISTORY) {
                isAiReady = false;
                dom.aiModelStatus.textContent = 'AI Model: Training...';
                const trendStatsForTrain = calculateTrendStats(history, STRATEGY_CONFIG, activePredictionTypes); 
                aiWorker.postMessage({ 
                    type: 'train', 
                    payload: { 
                        history: history,
                        historicalStreakData: trendStatsForTrain.streakData
                    } 
                });
            } else {
                isAiReady = false;
                dom.aiModelStatus.textContent = `AI Model: Need at least ${TRAINING_MIN_HISTORY} confirmed spins to train. (Current: ${successfulHistoryCount})`;
            }
        }

        function handleStrategyChange() {
            const currentWinningNumbers = history.slice().reverse().map(item => item.winningNumber).filter(n => n !== null);

            if (currentWinningNumbers.length < 3) {
                runAllAnalyses();
                renderHistory();
                return;
            }

            runSimulationOnHistory(currentWinningNumbers, STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES, {
                useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance,
                useLowestPocketDistance, useAdvancedCalculations, useDynamicStrategy,
                useAdaptivePlay, useTableChangeWarnings, useDueForHit, useNeighbourFocus,
                useLessStrict, useDynamicTerminalNeighbourCount
            });

            runAllAnalyses();
            renderHistory();
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            const dom = {
                number1: document.getElementById('number1'),
                number2: document.getElementById('number2'),
                resultDisplay: document.getElementById('resultDisplay'),
                historyList: document.getElementById('historyList'),
                analysisList: document.getElementById('analysisList'),
                boardStateAnalysis: document.getElementById('boardStateAnalysis'),
                boardStateConclusion: document.getElementById('boardStateConclusion'),
                historicalNumbersInput: document.getElementById('historicalNumbersInput'),
                imageUpload: document.getElementById('imageUpload'),
                imageUploadLabel: document.getElementById('imageUploadLabel'),
                analyzeHistoricalDataButton: document.getElementById('analyzeHistoricalDataButton'),
                historicalAnalysisMessage: document.getElementById('historicalAnalysisMessage'),
                aiModelStatus: document.getElementById('aiModelStatus'),
                recalculateAnalysisButton: document.getElementById('recalculateAnalysisButton'),
                trendConfirmationToggle: document.getElementById('trendConfirmationToggle'),
                weightedZoneToggle: document.getElementById('weightedZoneToggle'),
                proximityBoostToggle: document.getElementById('proximityBoostToggle'),
                pocketDistanceToggle: document.getElementById('pocketDistanceToggle'),
                lowestPocketDistanceToggle: document.getElementById('lowestPocketDistanceToggle'),
                advancedCalculationsToggle: document.getElementById('advancedCalculationsToggle'),
                dynamicStrategyToggle: document.getElementById('dynamicStrategyToggle'),
                adaptivePlayToggle: document.getElementById('adaptivePlayToggle'),
                tableChangeWarningsToggle: document.getElementById('tableChangeWarningsToggle'),
                dueForHitToggle: document.getElementById('dueForHitToggle'),
                neighbourFocusToggle: document.getElementById('neighbourFocusToggle'),
                lessStrictModeToggle: document.getElementById('lessStrictModeToggle'),
                dynamicTerminalNeighbourCountToggle: document.getElementById('dynamicTerminalNeighbourCountToggle'),
                videoUpload: document.getElementById('videoUpload'),
                videoUploadLabel: document.getElementById('videoUploadLabel'),
                videoStatus: document.getElementById('videoStatus'),
                videoPlayer: document.getElementById('videoPlayer'),
                frameCanvas: document.getElementById('frameCanvas'),
                setHighestWinRatePreset: document.getElementById('setHighestWinRatePreset'),
                setBalancedSafePreset: document.getElementById('setBalancedSafePreset'),
                setAggressiveSignalsPreset: document.getElementById('setAggressiveSignalsPreset'),
                rouletteWheelContainer: document.getElementById('rouletteWheelContainer'),
                rouletteLegend: document.getElementById('rouletteLegend'),
                strategyWeightsDisplay: document.getElementById('strategyWeightsDisplay'),
                videoUploadContainer: document.getElementById('videoUploadContainer'),
                videoControlsContainer: document.getElementById('videoControlsContainer'),
                analyzeVideoButton: document.getElementById('analyzeVideoButton'),
                clearVideoButton: document.getElementById('clearVideoButton'),
                historyInfoToggle: document.getElementById('historyInfoToggle'),
                historyInfoDropdown: document.getElementById('historyInfoDropdown'),
                winCount: document.getElementById('winCount'), 
                lossCount: document.getElementById('lossCount'),
                optimizationStatus: document.getElementById('optimizationStatus'),
                optimizationResult: document.getElementById('optimizationResult'),
                bestFitnessResult: document.getElementById('bestFitnessResult'),
                bestParamsResult: document.getElementById('bestParamsResult'),
                applyBestParamsButton: document.getElementById('applyBestParamsButton'),
                startOptimizationButton: document.getElementById('startOptimizationButton'),
                stopOptimizationButton: document.getElementById('stopOptimizationButton'),
                
                advancedSettingsHeader: document.getElementById('advancedSettingsHeader'),
                advancedSettingsContent: document.getElementById('advancedSettingsContent'),
                strategyLearningRatesSliders: document.getElementById('strategyLearningRatesSliders'),
                patternThresholdsSliders: document.getElementById('patternThresholdsSliders'),
                adaptiveInfluenceSliders: document.getElementById('adaptiveInfluenceSliders'),
                resetParametersButton: document.getElementById('resetParametersButton'),
                saveParametersButton: document.getElementById('saveParametersButton'),
                loadParametersInput: document.getElementById('loadParametersInput'),
                loadParametersLabel: document.getElementById('loadParametersLabel'),
                parameterStatusMessage: document.getElementById('parameterStatusMessage')
            };

            window.dom = dom; // Make dom object globally accessible for debugging if needed

            async function handleCalculation() {
                const num1Val = parseInt(dom.number1.value, 10);
                const num2Val = parseInt(dom.number2.value, 10);

                if (isNaN(num1Val) || isNaN(num2Val)) {
                    dom.resultDisplay.innerHTML = `<p class="text-red-600 font-medium text-center">Please enter two valid numbers.</p>`;
                    dom.resultDisplay.classList.remove('hidden');
                    return;
                }

                dom.resultDisplay.classList.add('hidden');

                const difference = Math.abs(num2Val - num1Val);
                const lastWinningNumber = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length - 1] : null;

                const newHistoryItem = {
                    id: Date.now(),
                    num1: num1Val,
                    num2: num2Val,
                    difference: difference,
                    status: 'pending',
                    hitTypes: [],
                    typeSuccessStatus: {},
                    winningNumber: null,
                    pocketDistance: null,
                    recommendedGroupId: null,
                    recommendationDetails: null
                };

                history.push(newHistoryItem);
                runAllAnalyses();
                renderHistory();
                drawRouletteWheel(difference, lastWinningNumber);
            }

            if (DEBUG_MODE) {
                console.log('DOM elements initialized:', Object.keys(dom).filter(key => dom[key] !== null));
            }

            function loadState() {
                const savedState = localStorage.getItem('terminalCalculatorState');
                if (savedState) {
                    const appState = JSON.parse(savedState);
                    history = (appState.history || []).map(item => ({
                        ...item,
                        recommendedGroupId: item.recommendedGroupId || null,
                        recommendedGroupPocketDistance: item.recommendedGroupPocketDistance ?? null,
                        recommendationDetails: item.recommendationDetails || null
                    }));
                    confirmedWinsLog = appState.confirmedWinsLog || [];
                    
                    if (appState.TOGGLES) {
                        useTrendConfirmation = appState.TOGGLES.useTrendConfirmation ?? DEFAULT_PARAMETERS.TOGGLES.useTrendConfirmation;
                        useWeightedZone = appState.TOGGLES.useWeightedZone ?? DEFAULT_PARAMETERS.TOGGLES.useWeightedZone;
                        useProximityBoost = appState.TOGGLES.useProximityBoost ?? DEFAULT_PARAMETERS.TOGGLES.useProximityBoost;
                        usePocketDistance = appState.TOGGLES.usePocketDistance ?? DEFAULT_PARAMETERS.TOGGLES.usePocketDistance;
                        useLowestPocketDistance = appState.TOGGLES.useLowestPocketDistance ?? DEFAULT_PARAMETERS.TOGGLES.useLowestPocketDistance;
                        useAdvancedCalculations = appState.TOGGLES.useAdvancedCalculations ?? DEFAULT_PARAMETERS.TOGGLES.useAdvancedCalculations;
                        useDynamicStrategy = appState.TOGGLES.useDynamicStrategy ?? DEFAULT_PARAMETERS.TOGGLES.useDynamicStrategy;
                        useAdaptivePlay = appState.TOGGLES.useAdaptivePlay ?? DEFAULT_PARAMETERS.TOGGLES.useAdaptivePlay;
                        useTableChangeWarnings = appState.TOGGLES.useTableChangeWarnings ?? DEFAULT_PARAMETERS.TOGGLES.useTableChangeWarnings;
                        useDueForHit = appState.TOGGLES.useDueForHit ?? DEFAULT_PARAMETERS.TOGGLES.useDueForHit;
                        useNeighbourFocus = appState.TOGGLES.useNeighbourFocus ?? DEFAULT_PARAMETERS.TOGGLES.useNeighbourFocus;
                        useLessStrict = appState.TOGGLES.useLessStrict ?? DEFAULT_PARAMETERS.TOGGLES.useLessStrict;
                        useDynamicTerminalNeighbourCount = appState.TOGGLES.useDynamicTerminalNeighbourCount ?? DEFAULT_PARAMETERS.TOGGLES.useDynamicTerminalNeighbourCount;
                    } else {
                        Object.assign(window, DEFAULT_PARAMETERS.TOGGLES); // Assign defaults to global toggles
                    }

                    if (appState.strategyStates) {
                        strategyStates = appState.strategyStates;
                    }
                    if (appState.patternMemory) {
                        patternMemory = appState.patternMemory;
                    }
                    if (appState.adaptiveFactorInfluences) {
                        for (const factor in adaptiveFactorInfluences) { 
                            if (appState.adaptiveFactorInfluences[factor] !== undefined) {
                                adaptiveFactorInfluences[factor] = appState.adaptiveFactorInfluences[factor];
                            }
                        }
                    }

                    if (appState.STRATEGY_CONFIG) {
                        Object.assign(STRATEGY_CONFIG, appState.STRATEGY_CONFIG);
                    } else {
                         Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                    }
                    if (appState.ADAPTIVE_LEARNING_RATES) {
                        Object.assign(ADAPTIVE_LEARNING_RATES, appState.ADAPTIVE_LEARNING_RATES);
                    } else {
                        Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                    }

                    updateAllTogglesUI();
                    updateActivePredictionTypes();
                    initializeAdvancedSettingsUI();
                } else {
                    Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                    Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                    Object.assign(window, DEFAULT_PARAMETERS.TOGGLES); // Assign defaults to global toggles

                    updateAllTogglesUI();
                    updateActivePredictionTypes();
                    initializeAdvancedSettingsUI();
                }
            }
            
            function handlePresetSelection(preset) {
                if (preset === 'highestWinRate') {
                    Object.assign(STRATEGY_CONFIG, {
                        learningRate_success: 0.35, 
                        learningRate_failure: 0.05, 
                        maxWeight: 6.0,             
                        minWeight: 0.03,            
                        decayFactor: 0.88,          
                        patternMinAttempts: 5,      
                        patternSuccessThreshold: 68,
                        triggerMinAttempts: 5,      
                        triggerSuccessThreshold: 63,
                    });
                    Object.assign(ADAPTIVE_LEARNING_RATES, {
                        SUCCESS: 0.15, 
                        FAILURE: 0.1,  
                        MIN_INFLUENCE: 0.2, 
                        MAX_INFLUENCE: 2.5,
                    });

                    useTrendConfirmation = true;   
                    useWeightedZone = true;        
                    useProximityBoost = false;     
                    usePocketDistance = false;     
                    useLowestPocketDistance = false; 
                    useAdvancedCalculations = true;  
                    useDynamicStrategy = true;     
                    useAdaptivePlay = true;        
                    useTableChangeWarnings = false; 
                    useDueForHit = false;          
                    useNeighbourFocus = true;      
                    useLessStrict = false;         
                    useDynamicTerminalNeighbourCount = true; 
                } else if (preset === 'balancedSafe') {
                    Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG); 
                    Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES); 

                    useTrendConfirmation = true;
                    useWeightedZone = true;
                    useProximityBoost = true;
                    usePocketDistance = false;
                    useLowestPocketDistance = false;
                    useAdvancedCalculations = false;
                    useDynamicStrategy = false;
                    useAdaptivePlay = false;
                    useTableChangeWarnings = false;
                    useDueForHit = false;
                    useNeighbourFocus = false;
                    useLessStrict = false;
                    useDynamicTerminalNeighbourCount = false;
                } else if (preset === 'aggressiveSignals') {
                    Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG); 
                    Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES); 

                    useTrendConfirmation = true;
                    useWeightedZone = true;
                    useProximityBoost = true;
                    usePocketDistance = false;
                    useLowestPocketDistance = false;
                    useAdvancedCalculations = false;
                    useDynamicStrategy = false;
                    useAdaptivePlay = false;
                    useTableChangeWarnings = false;
                    useDueForHit = false;
                    useNeighbourFocus = false;
                    useLessStrict = true;
                    useDynamicTerminalNeighbourCount = false;
                }
                updateAllTogglesUI(); 
                initializeAdvancedSettingsUI(); 
                updateActivePredictionTypes();
                
                runAllAnalyses(); 
            }

            function handleSwap() { 
                const v = dom.number1.value; dom.number1.value = dom.number2.value; dom.number2.value = v; 
            }
            async function handleHistoryAction(event) { 
                const button = event.target.closest('.delete-btn');
                if (!button) return;
                history = history.filter(item => item.id !== parseInt(button.dataset.id));
                
                confirmedWinsLog = history.map(item => item.winningNumber).filter(n => n !== undefined && n !== null).reverse();
                
                labelHistoryFailures(history.slice().sort((a, b) => a.id - b.id), STRATEGY_CONFIG, useDynamicTerminalNeighbourCount); 
                
                history.forEach((item, i) => {
                    const historySliceForStreak = history.slice(0, i + 1);
                    const trendStats = calculateTrendStats(historySliceForStreak, STRATEGY_CONFIG, activePredictionTypes); 
                    let maxConfirmedStreak = 0;
                    if (item.status === 'success' && item.typeSuccessStatus) {
                        for(const typeId of item.hitTypes) {
                            if (trendStats.currentStreaks[typeId] > maxConfirmedStreak) {
                                maxConfirmedStreak = trendStats.currentStreaks[typeId];
                            }
                        }
                    }
                    item.confirmedStreak = maxConfirmedStreak;
                });

                runAllAnalyses();
                renderHistory();
                drawRouletteWheel();
                
                
                if (history.filter(item => item.status === 'success').length >= TRAINING_MIN_HISTORY) {
                    isAiReady = false;
                    dom.aiModelStatus.textContent = 'AI Model: Training...';
                    aiWorker.postMessage({ type: 'train', payload: { history: history } });
                } else {
                    isAiReady = false;
                    dom.aiModelStatus.textContent = `AI Model: Need at least ${TRAINING_MIN_HISTORY} confirmed spins to train. (Current: ${history.filter(item => item.status === 'success').length})`;
                    aiWorker.postMessage({ type: 'clear_model' });
                }
            }
            async function handleClearInputs() { 
                dom.number1.value = '';
                dom.number2.value = '';
                dom.resultDisplay.classList.add('hidden');
                dom.number1.focus();
                drawRouletteWheel();
                if (dom.resultDisplay.textContent.includes('valid numbers')) {
                                            dom.resultDisplay.textContent = '';
                }
            }
            async function handleClearHistory() { 
                history = [];
                confirmedWinsLog = [];
                patternMemory = {};
                adaptiveFactorInfluences = {
                    'Hit Rate': 1.0,
                    'Streak': 1.0,
                    'Proximity to Last Spin': 1.0,
                    'Hot Zone Weighting': 1.0,
                    'High AI Confidence': 1.0,
                    'Statistical Trends': 1.0
                };
                isAiReady = false;
                dom.aiModelStatus.textContent = `AI Model: Need at least ${TRAINING_MIN_HISTORY} confirmed spins to train.`;
                runAllAnalyses();
                renderHistory();
                
                dom.historicalAnalysisMessage.textContent = 'History cleared.';
                drawRouletteWheel();
                
                aiWorker.postMessage({ type: 'clear_model' });
            }
            
            // --- NEW FUNCTIONS FOR ADVANCED SETTINGS UI AND FUNCTIONALITY ---

            // Helper to create a slider and its associated number input
            function createSlider(containerId, label, paramObj, paramName, min, max, step) {
                const container = document.getElementById(containerId);
                const id = `${paramName}Slider`; // Unique ID for the slider and input

                const sliderGroup = document.createElement('div');
                sliderGroup.className = 'slider-group';
                sliderGroup.innerHTML = `
                    <label for="${id}">${label}</label>
                    <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}">
                    <input type="number" id="${id}Input" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}" class="form-input text-sm">
                `;
                container.appendChild(sliderGroup);

                const slider = document.getElementById(id);
                const numberInput = document.getElementById(`${id}Input`);

                const updateValue = (sourceElement, targetElement, targetProp) => {
                    let val = parseFloat(sourceElement.value);
                    let defaultValueSource = 0; 
                    if (paramObj === STRATEGY_CONFIG && DEFAULT_PARAMETERS.STRATEGY_CONFIG.hasOwnProperty(paramName)) {
                        defaultValueSource = DEFAULT_PARAMETERS.STRATEGY_CONFIG[paramName];
                    } else if (paramObj === ADAPTIVE_LEARNING_RATES && DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES.hasOwnProperty(paramName)) {
                        defaultValueSource = DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES[paramName];
                    }
                    
                    if (isNaN(val)) val = defaultValueSource;
                    
                    val = Math.max(min, Math.min(max, val));

                    targetElement.value = val;
                    if (sourceElement.type === 'range') {
                        numberInput.value = val;
                    } else if (sourceElement.type === 'number') {
                        slider.value = val;
                    }

                    if (paramObj === STRATEGY_CONFIG) {
                        STRATEGY_CONFIG[targetProp] = val;
                    } else if (paramObj === ADAPTIVE_LEARNING_RATES) {
                        ADAPTIVE_LEARNING_RATES[targetProp] = val;
                    }

                    saveState(); 
                    dom.parameterStatusMessage.textContent = 'Parameter changed. Re-analyzing...';
                    handleStrategyChange(); 
                };

                slider.addEventListener('input', () => updateValue(slider, numberInput, paramName)); 
                numberInput.addEventListener('change', () => updateValue(numberInput, slider, paramName)); 
            }
            

            function initializeAdvancedSettingsUI() {
                dom.strategyLearningRatesSliders.innerHTML = '';
                dom.patternThresholdsSliders.innerHTML = '';
                dom.adaptiveInfluenceSliders.innerHTML = '';

                createSlider('strategyLearningRatesSliders', 'Success Learn Rate', STRATEGY_CONFIG, 'learningRate_success', 0.01, 1.0, 0.01);
                createSlider('strategyLearningRatesSliders', 'Failure Learn Rate', STRATEGY_CONFIG, 'learningRate_failure', 0.01, 0.5, 0.01);
                createSlider('strategyLearningRatesSliders', 'Max Weight', STRATEGY_CONFIG, 'maxWeight', 1.0, 10.0, 0.1);
                createSlider('strategyLearningRatesSliders', 'Min Weight', STRATEGY_CONFIG, 'minWeight', 0.0, 1.0, 0.01);
                createSlider('strategyLearningRatesSliders', 'Decay Factor', STRATEGY_CONFIG, 'decayFactor', 0.7, 0.99, 0.01);

                createSlider('patternThresholdsSliders', 'Pattern Min Attempts', STRATEGY_CONFIG, 'patternMinAttempts', 1, 20, 1);
                createSlider('patternThresholdsSliders', 'Pattern Success %', STRATEGY_CONFIG, 'patternSuccessThreshold', 50, 100, 1);
                createSlider('patternThresholdsSliders', 'Trigger Min Attempts', STRATEGY_CONFIG, 'triggerMinAttempts', 1, 20, 1);
                createSlider('patternThresholdsSliders', 'Trigger Success %', STRATEGY_CONFIG, 'triggerSuccessThreshold', 50, 100, 1);

                createSlider('adaptiveInfluenceSliders', 'Adaptive Success Rate', ADAPTIVE_LEARNING_RATES, 'SUCCESS', 0.01, 0.5, 0.01);
                createSlider('adaptiveInfluenceSliders', 'Adaptive Failure Rate', ADAPTIVE_LEARNING_RATES, 'FAILURE', 0.01, 0.5, 0.01);
                createSlider('adaptiveInfluenceSliders', 'Min Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MIN_INFLUENCE', 0.0, 1.0, 0.01);
                createSlider('adaptiveInfluenceSliders', 'Max Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MAX_INFLUENCE', 1.0, 5.0, 0.1);
            }

            function resetAllParameters() {
                Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
                Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
                Object.assign(window, DEFAULT_PARAMETERS.TOGGLES); 

                updateAllTogglesUI(); 
                initializeAdvancedSettingsUI(); 
                dom.parameterStatusMessage.textContent = 'Parameters reset to defaults.';
                handleHistoricalAnalysis(); 
            }

            function saveParametersToFile() {
                const parametersToSave = {
                    STRATEGY_CONFIG: STRATEGY_CONFIG,
                    ADAPTIVE_LEARNING_RATES: ADAPTIVE_LEARNING_RATES,
                    TOGGLES: { 
                        useTrendConfirmation, useWeightedZone, useProximityBoost, usePocketDistance, useLowestPocketDistance,
                        useAdvancedCalculations, useDynamicStrategy, useAdaptivePlay, useTableChangeWarnings,
                        useDueForHit, useNeighbourFocus, useLessStrict, useDynamicTerminalNeighbourCount
                    }
                };
                const dataStr = JSON.stringify(parametersToSave, null, 2); 
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'roulette_parameters.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                dom.parameterStatusMessage.textContent = 'Parameters saved to roulette_parameters.json';
            }

            async function loadParametersFromFile(event) {
                const file = event.target.files[0];
                if (!file) {
                    dom.parameterStatusMessage.textContent = 'No file selected.';
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const loadedParams = JSON.parse(e.target.result);
                        
                        if (loadedParams.STRATEGY_CONFIG) {
                            Object.assign(STRATEGY_CONFIG, loadedParams.STRATEGY_CONFIG);
                        }
                        if (loadedParams.ADAPTIVE_LEARNING_RATES) {
                            Object.assign(ADAPTIVE_LEARNING_RATES, loadedParams.ADAPTIVE_LEARNING_RATES);
                        }
                        if (loadedParams.TOGGLES) {
                            Object.keys(loadedParams.TOGGLES).forEach(key => {
                                if (window.hasOwnProperty(key)) { 
                                    window[key] = loadedParams.TOGGLES[key];
                                }
                            });
                        }

                        updateAllTogglesUI(); 
                        initializeAdvancedSettingsUI(); 
                        dom.parameterStatusMessage.textContent = 'Parameters loaded successfully!';
                        handleHistoricalAnalysis(); 

                    } catch (error) {
                        console.error('Error parsing or applying parameters from file:', error);
                        dom.parameterStatusMessage.textContent = `Error loading parameters: ${error.message}`;
                    } finally {
                        event.target.value = ''; 
                    }
                };
                reader.readAsText(file);
            }

            function toggleParameterSliders(enable) {
                const settingsContent = document.getElementById('advancedSettingsContent');
                if (settingsContent) {
                    const controls = settingsContent.querySelectorAll('input, button');
                    controls.forEach(control => {
                        if (!control.closest('.flex.justify-between.items-center.cursor-pointer')) {
                            control.disabled = !enable;
                        }
                    });
                }
                
                document.getElementById('setHighestWinRatePreset').disabled = !enable;
                document.getElementById('setBalancedSafePreset').disabled = !enable;
                document.getElementById('setAggressiveSignalsPreset').disabled = !enable;
                document.getElementById('resetParametersButton').disabled = !enable;
                document.getElementById('saveParametersButton').disabled = !enable;
                document.getElementById('loadParametersLabel').classList.toggle('btn-disabled', !enable);
            }

            aiWorker = new Worker('aiWorker.js');
            optimizationWorker = new Worker('optimizationWorker.js');

            optimizationWorker.onmessage = (event) => {
                const { type, payload } = event.data;
                const dom = window.dom; // Access global dom object

                switch (type) {
                    case 'progress':
                        dom.optimizationStatus.innerHTML = `Evolving... Generation: <strong>${payload.generation}/${payload.maxGenerations}</strong><br>Variations Processed: <strong>${payload.processedCount}</strong><br>Best W/L Ratio: <strong>${payload.bestFitness}</strong>`;
                        bestFoundParams = payload.bestIndividual; 
                        break;
                    case 'complete':
                        dom.optimizationStatus.textContent = 'Optimization finished!';
                        dom.optimizationResult.classList.remove('hidden');
                        dom.bestFitnessResult.textContent = payload.bestFitness;
                        dom.bestParamsResult.textContent = JSON.stringify(payload.bestIndividual, null, 2);
                        bestFoundParams = payload.bestIndividual;
                        toggleParameterSliders(true); 
                        dom.startOptimizationButton.disabled = false;
                        dom.stopOptimizationButton.disabled = true;
                        break;
                    case 'stopped':
                        dom.optimizationStatus.textContent = 'Optimization stopped by user.';
                        toggleParameterSliders(true); 
                        dom.startOptimizationButton.disabled = false;
                        dom.stopOptimizationButton.disabled = true;
                        break;
                }
            };

            aiWorker.onmessage = (event) => {
                const { type, message, probabilities, payload } = event.data;
                const dom = window.dom; // Access global dom object

                if (DEBUG_MODE) {
                    console.log(`Main: Received message from worker: ${type}`);
                }
                switch (type) {
                    case 'status':
                        dom.aiModelStatus.textContent = message;
                        if (message.includes('Ready!')) {
                            isAiReady = true;
                        } else if (message.includes('Training') || message.includes('Completed') || message.includes('initiated')) {
                            isAiReady = false;
                        } else if (message.includes('failed')) {
                            isAiReady = false;
                            dom.aiModelStatus.textContent = message;
                        }
                        break;
                    case 'predictionResult':
                        break;
                    case 'saveScaler':
                        localStorage.setItem('roulette-ml-scaler', payload);
                        break;
                }
            };

            if (DEBUG_MODE) {
                console.log('Main: Sending initial config to worker.');
            }
            const savedScaler = localStorage.getItem('roulette-ml-scaler'); 
            const trendStatsForInit = calculateTrendStats(history, STRATEGY_CONFIG, activePredictionTypes); 
            aiWorker.postMessage({ 
                type: 'init', 
                payload: { 
                    history: history,
                    allPredictionTypes: clonablePredictionTypes,
                    terminalMapping: terminalMapping,
                    rouletteWheel: rouletteWheel,
                    scaler: savedScaler, 
                    historicalStreakData: trendStatsForInit.streakData
                } 
            });


            // --- Event Listeners and Initial Load ---
            // Attaching event listeners after DOM is fully loaded and functions are defined

            document.getElementById('calculateButton').addEventListener('click', handleCalculation);
            document.getElementById('clearInputsButton').addEventListener('click', handleClearInputs);
            document.getElementById('swapButton').addEventListener('click', handleSwap);
            document.getElementById('clearHistoryButton').addEventListener('click', handleClearHistory);
            
            document.getElementById('historyList').addEventListener('click', (event) => { // Delegate delete button clicks
                if (event.target.closest('.delete-btn')) {
                    handleHistoryAction(event);
                }
            });

            document.getElementById('analyzeHistoricalDataButton').addEventListener('click', handleHistoricalAnalysis);
            document.getElementById('recalculateAnalysisButton').addEventListener('click', runAllAnalyses);

            document.getElementById('videoUpload').addEventListener('change', handleVideoUpload);
            document.getElementById('analyzeVideoButton').addEventListener('click', startVideoAnalysis);
            document.getElementById('clearVideoButton').addEventListener('click', clearVideoState);

            document.getElementById('setHighestWinRatePreset').addEventListener('click', () => handlePresetSelection('highestWinRate'));
            document.getElementById('setBalancedSafePreset').addEventListener('click', () => handlePresetSelection('balancedSafe'));
            document.getElementById('setAggressiveSignalsPreset').addEventListener('click', () => handlePresetSelection('aggressiveSignals'));

            document.getElementById('resetParametersButton').addEventListener('click', resetAllParameters);
            document.getElementById('saveParametersButton').addEventListener('click', saveParametersToFile);
            document.getElementById('loadParametersInput').addEventListener('change', loadParametersFromFile);

            document.getElementById('startOptimizationButton').addEventListener('click', () => {
                const dom = window.dom; // Access global dom object

                if (history.length < 20) {
                        dom.optimizationStatus.textContent = 'Error: Need at least 20 history items to run optimization.';
                        return;
                }

                dom.optimizationStatus.textContent = 'Starting optimization...';
                dom.optimizationResult.classList.add('hidden');
                toggleParameterSliders(false); 
                dom.startOptimizationButton.disabled = true;
                dom.stopOptimizationButton.disabled = false;

                // Pass the source code of helper functions and necessary fixed data
                const helpers = {
                    calculateTrendStats: calculateTrendStats.toString(),
                    getBoardStateStats: getBoardStateStats.toString(),
                    getRecommendation: getRecommendation.toString(),
                    runNeighbourAnalysis: runNeighbourAnalysis.toString(),
                    getHitZone: getHitZone.toString(),
                    getNeighbours: getNeighbours.toString(),
                    calculatePocketDistance: calculatePocketDistance.toString(),
                    evaluateCalculationStatus: evaluateCalculationStatus.toString(), 
                    // Pass current global values for toggles used in optimization simulation
                    useDynamicTerminalNeighbourCount: useDynamicTerminalNeighbourCount, 
                    useProximityBoost: useProximityBoost,
                    useWeightedZone: useWeightedZone,
                    useNeighbourFocus: useNeighbourFocus,
                    useTrendConfirmation: useTrendConfirmation,
                    isAiReady: isAiReady, // Current AI readiness for simulation purposes
                    
                    // Essential data that functions rely on
                    allPredictionTypes: clonablePredictionTypes,
                    terminalMapping: terminalMapping,
                    rouletteWheel: rouletteWheel
                };

                optimizationWorker.postMessage({ type: 'start', payload: { history, helpers } });
            });

            document.getElementById('stopOptimizationButton').addEventListener('click', () => {
                optimizationWorker.postMessage({ type: 'stop' });
            });

            document.getElementById('applyBestParamsButton').addEventListener('click', () => {
                if (bestFoundParams) {
                    Object.assign(STRATEGY_CONFIG, {
                        learningRate_success: bestFoundParams.learningRate_success,
                        learningRate_failure: bestFoundParams.learningRate_failure,
                        maxWeight: bestFoundParams.maxWeight,
                        minWeight: bestFoundParams.minWeight,
                        decayFactor: bestFoundParams.decayFactor,
                        patternMinAttempts: bestFoundParams.patternMinAttempts,
                        patternSuccessThreshold: bestFoundParams.patternSuccessThreshold,
                        triggerMinAttempts: bestFoundParams.triggerMinAttempts,
                        triggerSuccessThreshold: bestFoundParams.triggerSuccessThreshold,
                    });
                    Object.assign(ADAPTIVE_LEARNING_RATES, {
                        SUCCESS: bestFoundParams.adaptiveSuccessRate,
                        FAILURE: bestFoundParams.adaptiveFailureRate,
                        MIN_INFLUENCE: bestFoundParams.minAdaptiveInfluence,
                        MAX_INFLUENCE: bestFoundParams.maxAdaptiveInfluence,
                    });

                    initializeAdvancedSettingsUI();
                    document.getElementById('optimizationStatus').textContent = 'Best parameters applied and saved!';
                    handleHistoricalAnalysis();
                }
            });

            dom.trendConfirmationToggle.addEventListener('change', () => { useTrendConfirmation = dom.trendConfirmationToggle.checked; handleStrategyChange(); });
            dom.weightedZoneToggle.addEventListener('change', () => { useWeightedZone = dom.weightedZoneToggle.checked; handleStrategyChange(); });
            dom.proximityBoostToggle.addEventListener('change', () => { useProximityBoost = dom.proximityBoostToggle.checked; handleStrategyChange(); });
            dom.pocketDistanceToggle.addEventListener('change', () => { usePocketDistance = dom.pocketDistanceToggle.checked; renderHistory(); });
            dom.lowestPocketDistanceToggle.addEventListener('change', () => { useLowestPocketDistance = dom.lowestPocketDistanceToggle.checked; handleStrategyChange(); });
            dom.advancedCalculationsToggle.addEventListener('change', async () => {
                useAdvancedCalculations = dom.advancedCalculationsToggle.checked;
                updateActivePredictionTypes();
                handleStrategyChange(); 
                const num1Val = parseInt(dom.number1.value, 10);
                const num2Val = parseInt(dom.number2.value, 10);
                if (!isNaN(num1Val) && !isNaN(num2Val)) {
                    drawRouletteWheel(Math.abs(num2Val - num1Val), confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length - 1] : null);
                }
            });
            dom.dynamicStrategyToggle.addEventListener('change', () => { useDynamicStrategy = dom.dynamicStrategyToggle.checked; handleStrategyChange(); });
            dom.adaptivePlayToggle.addEventListener('change', () => { useAdaptivePlay = dom.adaptivePlayToggle.checked; handleStrategyChange(); });
            dom.tableChangeWarningsToggle.addEventListener('change', () => { useTableChangeWarnings = dom.tableChangeWarningsToggle.checked; handleStrategyChange(); });
            dom.dueForHitToggle.addEventListener('change', () => { useDueForHit = dom.dueForHitToggle.checked; handleStrategyChange(); });
            dom.neighbourFocusToggle.addEventListener('change', () => { useNeighbourFocus = dom.neighbourFocusToggle.checked; handleStrategyChange(); });
            dom.lessStrictModeToggle.addEventListener('change', () => { useLessStrict = dom.lessStrictModeToggle.checked; handleStrategyChange(); });
            dom.dynamicTerminalNeighbourCountToggle.addEventListener('change', () => {
                useDynamicTerminalNeighbourCount = dom.dynamicTerminalNeighbourCountToggle.checked;
                handleStrategyChange(); 
                const num1Val = parseInt(dom.number1.value, 10);
                const num2Val = parseInt(dom.number2.value, 10);
                if (!isNaN(num1Val) && !isNaN(num2Val)) {
                    drawRouletteWheel(Math.abs(num2Val - num1Val), confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length - 1] : null);
                }
            });

            [dom.number1, dom.number2].forEach(input => input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleCalculation();
                }
            }));
            
            dom.historyInfoToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                dom.historyInfoDropdown.classList.toggle('hidden');
            });

            document.addEventListener('click', (e) => {
                if (dom.historyInfoDropdown && !dom.historyInfoDropdown.contains(e.target) && !dom.historyInfoToggle.contains(e.target)) {
                    dom.historyInfoDropdown.classList.add('hidden');
                }
            });

            loadState(); 
            runAllAnalyses();
            renderHistory();
            const initialNum1 = parseInt(dom.number1.value, 10);
            const initialNum2 = parseInt(dom.number2.value, 10);
            const lastWinningNumberOnLoad = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length -1] : null;
            if (!isNaN(initialNum1) && !isNaN(initialNum2)) {
                drawRouletteWheel(Math.abs(initialNum2 - initialNum1), lastWinningNumberOnLoad);
            } else {
                drawRouletteWheel(null, lastWinningNumberOnLoad);
            }
        });
    </script>
</body>
</html>

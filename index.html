<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Terminal Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card { background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 35px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0,0,0,0.06); }
        .form-input { border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; font-size: 1rem; width: 100%; transition: border-color 0.3s ease; }
        .form-input:focus { outline: none; border-color: #4f46e5; }
        .btn { font-weight: 600; padding: 12px 20px; border-radius: 8px; transition: all 0.2s ease; border: 2px solid transparent; cursor: pointer; }
        .btn:disabled { background-color: #e5e7eb; color: #6b7280; cursor: not-allowed; }
        .btn-primary { background-color: #4f46e5; color: #ffffff; }
        .btn-primary:hover:not(:disabled) { background-color: #4338ca; transform: translateY(-1px); }
        .btn-secondary { background-color: #eef2ff; color: #4f46e5; }
        .btn-secondary:hover:not(:disabled) { background-color: #e0e7ff; }
        .btn-danger { background-color: #fee2e2; color: #dc2626; }
        .btn-danger:hover { background-color: #fecaca; }
        .history-list, .analysis-list { max-height: 350px; overflow-y: auto; padding-right: 8px; }
        .history-item { background-color: #f8fafc; border: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s ease; padding: 12px 20px; border-radius: 12px; position: relative; flex-wrap: wrap; }
        .history-item.is-success { background-color: #f0fdf4; border-color: #22c55e; }
        .history-item.is-fail { background-color: #fef2f2; border-color: #ef4444; }
        .state-badge { font-size: 0.75rem; font-weight: 700; padding: 2px 6px; border-radius: 6px; color: white; position: absolute; top: -10px; left: 50%; transform: translateX(-50%); z-index: 10; white-space: nowrap; }
        .bg-amber-500 { background-color: #f59e0b; }
        .bg-blue-500 { background-color: #3b82f6; }
        .bg-red-500 { background-color: #ef4444; }
        .bg-sumMinus { background-color: #8b5cf6; }
        .bg-sumResult { background-color: #10b981; }
        .bg-sumPlus { background-color: #f43f5e; }
        .status-box { width: 24px; height: 24px; border-radius: 6px; transition: all 0.2s ease; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .status-box svg { width: 16px; height: 16px; stroke-width: 2.5; color: #ffffff; }
        .success-box { border: 2px solid #dcfce7; background-color: #f0fdf4; }
        .is-success .success-box { background-color: #22c55e; border-color: #16a34a; }
        .fail-box { border: 2px solid #fee2e2; background-color: #fef2f2; }
        .is-fail .fail-box { background-color: #ef4444; border-color: #dc2626; }
        .delete-btn { width: 32px; height: 32px; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; flex-shrink: 0; display: flex; align-items: center; justify-content: center; border: 2px solid #e5e7eb; background-color: #fff; }
        .delete-btn svg { color: #9ca3af; width: 20px; height: 20px; stroke-width: 2; }
        .delete-btn:hover { background-color: #f3f4f6; border-color: #d1d5db;}
        .swap-btn { height: 40px; width: 40px; background-color: #fff; border: 2px solid #e2e8f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; color: #9ca3af; }
        .swap-btn:hover { color: #4f46e5; border-color: #c7d2fe; transform: rotate(180deg); }
        .result-display { border-radius: 12px; background-color: #f8fafc; padding: 16px; }
        .toggle-label { display: flex; align-items: center; justify-content: space-between; cursor: pointer; width: 100%; padding: 0.5rem 0; }
        .toggle-checkbox { opacity: 0; width: 0; height: 0; position: absolute; }
        .toggle-switch { width: 52px; height: 32px; background-color: #e5e7eb; border-radius: 9999px; position: relative; transition: background-color 0.2s ease-in-out; flex-shrink: 0; }
        .toggle-knob { position: absolute; top: 2px; left: 2px; width: 28px; height: 28px; background-color: white; border-radius: 9999px; transition: transform 0.2s ease-in-out; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .toggle-checkbox:checked + .toggle-switch { background-color: #4f46e5; }
        .toggle-checkbox:checked + .toggle-switch .toggle-knob { transform: translateX(20px); }
        .strategy-guide-content { max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out, padding-top 0.5s ease-in-out, margin-top 0.5s ease-in-out; padding-top: 0; padding-bottom: 0; border-top: 1px solid transparent; }
        .strategy-guide-content.open { max-height: 1000px; margin-top: 1rem; padding-top: 1rem; border-color: #e5e7eb; overflow-y: auto; }
        .strategy-guide-content h4 { font-weight: 600; color: #374151; margin-top: 0.5rem; }
        .strategy-guide-content p { color: #6b7280; font-size: 0.875rem; }
        .slider-group { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem; }
        .slider-group label { flex-basis: 120px; font-size: 0.875rem; color: #4b5563; }
        .slider-group input[type="range"] { flex-grow: 1; -webkit-appearance: none; width: 100%; height: 8px; border-radius: 5px; background: #d1d5db; outline: none; opacity: 0.7; -webkit-transition: .2s; transition: opacity .2s; }
        .slider-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #4f46e5; cursor: pointer; }
        .slider-group input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #4f46e5; cursor: pointer; }
        .slider-group input[type="number"] { width: 70px; padding: 0.5rem; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 0.875rem; text-align: center; }
        #rouletteWheelContainer { width: 100%; display: flex; justify-content: center; align-items: center; margin-top: 1rem; }
        #rouletteWheel { border: 2px solid #e2e8f0; border-radius: 50%; background-color: #f8fafc; }
        .wheel-number-circle.red { fill: #ef4444; stroke: #b91c1c; }
        .wheel-number-circle.black { fill: #1f2937; stroke: #111827; }
        .wheel-number-circle.green { fill: #22c55e; stroke: #16a34a; }
        .wheel-number-text { font-size: 8px; font-weight: 600; fill: white; pointer-events: none; }
        .wheel-number-circle.highlight-diffMinus { stroke: #f59e0b; stroke-width: 3px; }
        .wheel-number-circle.highlight-diffResult { stroke: #3b82f6; stroke-width: 3px; }
        .wheel-number-circle.highlight-diffPlus { stroke: #ef4444; stroke-width: 3px; }
        .wheel-number-circle.highlight-sumMinus { stroke: #8b5cf6; stroke-width: 3px; }
        .wheel-number-circle.highlight-sumResult { stroke: #10b981; stroke-width: 3px; }
        .wheel-number-circle.highlight-sumPlus { stroke: #f43f5e; stroke-width: 3px; }
        .wheel-number-circle.highlight-winning { stroke: #10b981; stroke-width: 4px; }
        .roulette-legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: #4b5563; }
        .roulette-legend-color { width: 16px; height: 16px; border-radius: 4px; }
        .bg-roulette-red { background-color: #ef4444; }
        .bg-roulette-black { background-color: #1f2937; }
        .bg-roulette-green { background-color: #22c55e; }
        .text-pink-400 { color: #f472b6; }
        .text-purple-700 { color: #7e22ce; }
        .pattern-alert { background-color: #eef2ff; border: 2px solid #c7d2fe; color: #4338ca; border-radius: 8px; padding: 12px; margin-top: 1rem; font-size: 0.875rem; text-align: center; font-weight: 500; }
        .ai-details-section { background-color: #f0f4f8; border-top: 1px solid transparent; border-radius: 0 0 8px 8px; padding: 0 16px; margin-top: 0; font-size: 0.8rem; color: #4a5568; max-height: 0; overflow: hidden; opacity: 0; visibility: hidden; transition: max-height 0.5s ease-out, padding 0.5s ease-out, margin-top 0.5s ease-out, border-top-color 0.5s ease-out, opacity 0.3s ease-out, visibility 0.3s ease-out; }
        .ai-details-section.open { max-height: 500px; padding: 12px 16px; margin-top: 8px; border-top-color: #e2e8f0; opacity: 1; visibility: visible; }
        .ai-details-section ul { list-style: none; padding: 0; margin: 0; }
        .ai-details-section li { margin-bottom: 4px; }
        .ai-details-toggle { display: block; width: fit-content; margin-top: 8px; font-size: 0.75rem; font-weight: 600; color: #4f46e5; cursor: pointer; text-decoration: underline; transition: color 0.2s ease; }
        .ai-details-toggle:hover { color: #4338ca; }
    </style>
</head>
<body class="text-gray-800 py-10 px-4">
    <div class="w-full max-w-6xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-8">
        <main class="space-y-8">
            </main>
        <aside class="space-y-8">
            </aside>
    </div>

    <script>
    // ===============================================
    // GLOBAL VARIABLES & CONFIGURATION
    // ===============================================
    const GOOGLE_API_KEY = "YOUR_API_KEY_HERE";
    const DEBUG_MODE = true;

    let STRATEGY_CONFIG = {
        learningRate_success: 0.35, learningRate_failure: 0.05, maxWeight: 6.0, minWeight: 0.03,
        decayFactor: 0.88, patternMinAttempts: 5, patternSuccessThreshold: 68,
        triggerMinAttempts: 5, triggerSuccessThreshold: 63,
    };
    let ADAPTIVE_LEARNING_RATES = {
        SUCCESS: 0.15, FAILURE: 0.1, MIN_INFLUENCE: 0.2, MAX_INFLUENCE: 2.5,
    };
    const DEFAULT_PARAMETERS = {
        STRATEGY_CONFIG: JSON.parse(JSON.stringify(STRATEGY_CONFIG)),
        ADAPTIVE_LEARNING_RATES: JSON.parse(JSON.stringify(ADAPTIVE_LEARNING_RATES)),
        TOGGLES: { useTrendConfirmation: false, useWeightedZone: true, useProximityBoost: true, usePocketDistance: false, useLowestPocketDistance: false, useAdvancedCalculations: false, useDynamicStrategy: false, useAdaptivePlay: false, useTableChangeWarnings: false, useDueForHit: false, useNeighbourFocus: false, useLessStrict: false, useDynamicTerminalNeighbourCount: false }
    };

    const TRAINING_MIN_HISTORY = 10;
    const AI_SEQUENCE_LENGTH = 5;

    let aiWorker, optimizationWorker, bestFoundParams = null;
    let history = [], confirmedWinsLog = [], patternMemory = {};
    let isAiReady = false;
    let strategyStates = {
        weightedZone: { weight: 1.0, name: 'Neighbour Weighting' },
        proximityBoost: { weight: 1.0, name: 'Proximity Boost' }
    };
    let adaptiveFactorInfluences = { 'Hit Rate': 1.0, 'Streak': 1.0, 'Proximity to Last Spin': 1.0, 'Hot Zone Weighting': 1.0, 'High AI Confidence': 1.0, 'Statistical Trends': 1.0 };
    let currentVideoURL = null;

    let useTrendConfirmation = false, useWeightedZone = true, useProximityBoost = true, usePocketDistance = false,
        useLowestPocketDistance = false, useAdvancedCalculations = false, useDynamicStrategy = false,
        useAdaptivePlay = false, useTableChangeWarnings = false, useDueForHit = false,
        useNeighbourFocus = false, useLessStrict = false, useDynamicTerminalNeighbourCount = false;
        
    const rouletteWheel = [0, 26, 3, 35, 12, 28, 7, 29, 18, 22, 9, 31, 14, 20, 1, 33, 16, 24, 5, 10, 23, 8, 30, 11, 36, 13, 27, 6, 34, 17, 25, 2, 21, 4, 19, 15, 32];
    const terminalMapping = { 0:[4,6],1:[8],2:[7,9],3:[8],4:[11],5:[12,10],6:[11],7:[14,2],8:[15,13,3,1],9:[14,2],10:[17,5],11:[18,16,6,4],12:[17,5],13:[20,23],14:[9,21,7,19],15:[8,20],16:[11],17:[12,24,10,22],18:[11,23],19:[14,26],20:[13,25,15,27],21:[14,26],22:[17,29],23:[18,30,16,28],24:[17,29],25:[20,32],26:[19,31,33,21],27:[20,32],28:[23,35],29:[22,34,24,36],30:[23,35],31:[26],32:[25,27],33:[26],34:[29],35:[28,30],36:[29] };
    
    // ===============================================
    // ALL FUNCTION DEFINITIONS
    // ===============================================

    function toggleGuide(contentId) { const content = document.getElementById(contentId); if (content) content.classList.toggle('open'); }

    function runSimulationOnHistory(spinsToProcess) {
        history = []; confirmedWinsLog = []; patternMemory = {};
        strategyStates = { weightedZone: { weight: 1.0, name: 'Neighbour Weighting' }, proximityBoost: { weight: 1.0, name: 'Proximity Boost' } };
        adaptiveFactorInfluences = { 'Hit Rate': 1.0, 'Streak': 1.0, 'Proximity to Last Spin': 1.0, 'Hot Zone Weighting': 1.0, 'High AI Confidence': 1.0, 'Statistical Trends': 1.0 };
        const baseTimestamp = Date.now();
        for (let i = 0; i <= spinsToProcess.length - 3; i++) {
            const num1 = spinsToProcess[i], num2 = spinsToProcess[i + 1], winningNumber = spinsToProcess[i + 2];
            const diff = Math.abs(num2 - num1); const calcId = baseTimestamp + i;
            const trendStatsAtCalc = calculateTrendStats(history);
            const boardStatsAtCalc = getBoardStateStats(history);
            const neighbourScoresAtCalc = runNeighbourAnalysis(false, history);
            const recommendationAtCalc = getRecommendation(trendStatsAtCalc, boardStatsAtCalc, neighbourScoresAtCalc, diff, num1, num2, false, null, adaptiveFactorInfluences);
            const newHistoryItem = {
                id: calcId, num1, num2, difference: diff, status: 'pending', hitTypes: [], typeSuccessStatus: {}, confirmedStreak: 0, pocketDistance: null, winningNumber,
                recommendedGroupId: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.type.id : null,
                recommendationDetails: recommendationAtCalc.bestCandidate ? recommendationAtCalc.bestCandidate.details : null
            };
            evaluateCalculationStatus(newHistoryItem, winningNumber);
            history.push(newHistoryItem); updateStrategyWeights(newHistoryItem);
            if (newHistoryItem.recommendedGroupId && newHistoryItem.recommendationDetails?.primaryDrivingFactor) {
                const primaryFactor = newHistoryItem.recommendationDetails.primaryDrivingFactor;
                const recommendedHit = newHistoryItem.hitTypes.includes(newHistoryItem.recommendedGroupId);
                if (adaptiveFactorInfluences[primaryFactor] === undefined) adaptiveFactorInfluences[primaryFactor] = 1.0;
                if (recommendedHit) adaptiveFactorInfluences[primaryFactor] = Math.min(ADAPTIVE_LEARNING_RATES.MAX_INFLUENCE, adaptiveFactorInfluences[primaryFactor] + ADAPTIVE_LEARNING_RATES.SUCCESS);
                else adaptiveFactorInfluences[primaryFactor] = Math.max(ADAPTIVE_LEARNING_RATES.MIN_INFLUENCE, adaptiveFactorInfluences[primaryFactor] - ADAPTIVE_LEARNING_RATES.FAILURE);
            }
            if (!confirmedWinsLog.includes(winningNumber)) confirmedWinsLog.push(winningNumber);
            updatePatternMemory();
        }
        labelHistoryFailures(history);
        history.reverse();
        confirmedWinsLog = history.map(item => item.winningNumber).filter(n => n !== null).reverse();
        return history;
    }

    async function handleHistoricalAnalysis() {
        if (DEBUG_MODE) console.log('Analyze Historical Data button clicked.');
        const dom = { historicalAnalysisMessage: document.getElementById('historicalAnalysisMessage'), historicalNumbersInput: document.getElementById('historicalNumbersInput'), aiModelStatus: document.getElementById('aiModelStatus') };
        dom.historicalAnalysisMessage.textContent = 'Processing...';
        const rawInput = dom.historicalNumbersInput.value;
        if (!rawInput.trim()) { dom.historicalAnalysisMessage.textContent = 'Please paste historical numbers.'; return; }
        const numbers = rawInput.trim().split(/[\s,]+/).filter(Boolean).map(Number);
        if (numbers.length < 3 || numbers.some(isNaN) || numbers.some(n => n < 0 || n > 36)) { dom.historicalAnalysisMessage.textContent = 'Please provide at least 3 valid numbers (0-36).'; return; }
        const historicalSpinsChronological = numbers.slice().reverse();
        history = runSimulationOnHistory(historicalSpinsChronological);
        dom.historicalAnalysisMessage.textContent = `Processed ${history.length} entries.`;
        runAllAnalyses(); renderHistory(); drawRouletteWheel(); saveState();
        const successfulHistoryCount = history.filter(item => item.status === 'success').length;
        if (successfulHistoryCount >= TRAINING_MIN_HISTORY) {
            isAiReady = false;
            dom.aiModelStatus.textContent = 'AI Model: Training...';
            aiWorker.postMessage({ type: 'train', payload: { history: history } });
        } else {
            isAiReady = false;
            dom.aiModelStatus.textContent = `AI Model: Need ${TRAINING_MIN_HISTORY} confirmed spins to train. (Current: ${successfulHistoryCount})`;
        }
    }

    function handleStrategyChange() {
        if (DEBUG_MODE) console.log('Strategy toggle changed. Re-simulating.');
        const currentWinningNumbers = history.slice().reverse().map(item => item.winningNumber).filter(n => n !== null);
        if (currentWinningNumbers.length < 3) { runAllAnalyses(); renderHistory(); return; }
        history = runSimulationOnHistory(currentWinningNumbers);
        runAllAnalyses(); renderHistory(); saveState();
    }

    function getFullPredictionTypes() {
        return [
            { id: 'diffMinus', label: 'Minus', displayLabel: 'Minus Group', colorClass: 'bg-amber-500', textColor: '#d97706', calculateBase: (n1, n2) => Math.abs(n2 - n1) - 1 },
            { id: 'diffResult', label: 'Result', displayLabel: 'Result Group', colorClass: 'bg-blue-500', textColor: '#2563eb', calculateBase: (n1, n2) => Math.abs(n2 - n1) },
            { id: 'diffPlus', label: 'Plus', displayLabel: 'Plus Group', colorClass: 'bg-red-500', textColor: '#dc2626', calculateBase: (n1, n2) => Math.abs(n2 - n1) + 1 },
            { id: 'sumMinus', label: 'Sum (-1)', displayLabel: '+ and -1', colorClass: 'bg-sumMinus', textColor: '#8b5cf6', calculateBase: (n1, n2) => (n1 + n2) - 1 },
            { id: 'sumResult', label: 'Sum Result', displayLabel: '+', colorClass: 'bg-sumResult', textColor: '#10b981', calculateBase: (n1, n2) => (n1 + n2) },
            { id: 'sumPlus', label: 'Sum (+1)', displayLabel: '+ and +1', colorClass: 'bg-sumPlus', textColor: '#f43f5e', calculateBase: (n1, n2) => (n1 + n2) + 1 }
        ];
    }

    function getActivePredictionTypes() {
        const allTypes = getFullPredictionTypes();
        if (useAdvancedCalculations) return allTypes;
        return allTypes.filter(type => type.id.startsWith('diff'));
    }

    function getNeighbours(number, count) {
        const index = rouletteWheel.indexOf(number);
        if (index === -1) return [];
        const neighbours = new Set();
        const wheelSize = rouletteWheel.length;
        for (let i = 1; i <= count; i++) {
            neighbours.add(rouletteWheel[(index - i + wheelSize) % wheelSize]);
            neighbours.add(rouletteWheel[(index + i) % wheelSize]);
        }
        return Array.from(neighbours);
    }

    function getHitZone(baseNumber, terminals, winningNumber = null) {
        if (baseNumber < 0 || baseNumber > 36) return [];
        const hitZone = new Set([baseNumber]);
        const numTerminals = terminals ? terminals.length : 0;
        let baseNeighbourCount = (numTerminals === 1) ? 3 : (numTerminals >= 2) ? 1 : 0;
        if (baseNeighbourCount > 0) getNeighbours(baseNumber, baseNeighbourCount).forEach(n => hitZone.add(n));
        let terminalNeighbourCount;
        if (useDynamicTerminalNeighbourCount && winningNumber !== null) {
            if (baseNumber === winningNumber || (terminals && terminals.includes(winningNumber))) terminalNeighbourCount = 0;
            else terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
        } else {
            terminalNeighbourCount = (numTerminals === 1 || numTerminals === 2) ? 3 : (numTerminals > 2) ? 1 : 0;
        }
        if (terminals && terminals.length > 0) {
            terminals.forEach(t => {
                hitZone.add(t);
                if (terminalNeighbourCount > 0) getNeighbours(t, terminalNeighbourCount).forEach(n => hitZone.add(n));
            });
        }
        return Array.from(hitZone);
    }

    function getRouletteNumberColor(number) {
        if (number === 0) return 'green';
        const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
        if (redNumbers.includes(number)) return 'red';
        return 'black';
    }

    function drawRouletteWheel(currentDiff = null, lastWinningNumber = null) {
        const container = document.getElementById('rouletteWheelContainer');
        if (!container) return;
        container.innerHTML = '';
        const svgWidth = container.clientWidth || 300;
        const radius = (svgWidth / 2) * 0.8;
        const centerX = svgWidth / 2;
        const centerY = svgWidth / 2;
        const numberRadius = 15;
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgWidth}`);
        container.appendChild(svg);
        const highlightedNumbers = new Set();
        const hitZoneClasses = {};
        if (currentDiff !== null && !isNaN(currentDiff)) {
            const num1 = parseInt(document.getElementById('number1').value, 10);
            const num2 = parseInt(document.getElementById('number2').value, 10);
            const activeTypes = getActivePredictionTypes();
            const allTypes = getFullPredictionTypes();
            activeTypes.forEach(type => {
                const def = allTypes.find(t => t.id === type.id);
                if (!def) return;
                const baseNum = def.calculateBase(num1, num2);
                if (baseNum < 0 || baseNum > 36) return;
                const terminals = terminalMapping[baseNum] || [];
                const hitZone = getHitZone(baseNum, terminals, lastWinningNumber);
                hitZone.forEach(num => {
                    highlightedNumbers.add(num);
                    if (!hitZoneClasses[num]) hitZoneClasses[num] = `highlight-${type.id}`;
                });
            });
        }
        rouletteWheel.forEach((number, index) => {
            const angle = (index / rouletteWheel.length) * 2 * Math.PI - (Math.PI / 2);
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            const numberColor = getRouletteNumberColor(number);
            let strokeClass = '';
            if (lastWinningNumber !== null && number === lastWinningNumber) strokeClass = 'highlight-winning';
            else if (highlightedNumbers.has(number)) strokeClass = hitZoneClasses[number];
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x); circle.setAttribute("cy", y); circle.setAttribute("r", numberRadius);
            circle.setAttribute("class", `wheel-number-circle ${numberColor} ${strokeClass}`);
            svg.appendChild(circle);
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", x); text.setAttribute("y", y + 3); text.setAttribute("text-anchor", "middle");
            text.setAttribute("class", "wheel-number-text");
            text.textContent = number;
            svg.appendChild(text);
        });
    }

    function calculatePocketDistance(num1, num2) {
        const index1 = rouletteWheel.indexOf(num1);
        const index2 = rouletteWheel.indexOf(num2);
        if (index1 === -1 || index2 === -1) return Infinity;
        const directDistance = Math.abs(index1 - index2);
        return Math.min(directDistance, rouletteWheel.length - directDistance);
    }

    function updateWinLossCounter() {
        let wins = 0, losses = 0;
        history.forEach(item => {
            if (item.recommendedGroupId) {
                if (item.hitTypes && item.hitTypes.includes(item.recommendedGroupId)) wins++;
                else if (item.winningNumber !== null) losses++;
            }
        });
        document.getElementById('winCount').textContent = wins;
        document.getElementById('lossCount').textContent = losses;
    }

    function renderHistory() {
        updateWinLossCounter();
        const historyList = document.getElementById('historyList');
        historyList.innerHTML = `<li class="text-center text-gray-500 py-4">No calculations yet.</li>`;
        if (history.length === 0) return;
        historyList.innerHTML = '';
        const allTypes = getFullPredictionTypes();
        history.slice().sort((a, b) => b.id - a.id).forEach(item => {
            const li = document.createElement('li');
            li.className = 'history-item relative';
            if (item.status === 'success') li.classList.add('is-success');
            if (item.status === 'fail') li.classList.add('is-fail');
            let stateBadgeContent, stateBadgeClass = 'bg-gray-400';
            if (item.status === 'pending') stateBadgeContent = 'Pending';
            else if (item.recommendedGroupId !== null) {
                const recommendedType = allTypes.find(type => type.id === item.recommendedGroupId);
                const recommendedLabel = recommendedType?.displayLabel || 'Unknown Group';
                const recommendedColorClass = recommendedType?.colorClass || 'bg-gray-400';
                const recommendedHit = item.hitTypes.includes(item.recommendedGroupId);
                if (recommendedHit) {
                    stateBadgeContent = `Reco: ${recommendedLabel} (Hit)`;
                    stateBadgeClass = recommendedColorClass;
                } else {
                    const otherHitLabels = item.hitTypes.map(id => allTypes.find(type => type.id === id)?.displayLabel || id);
                    stateBadgeContent = otherHitLabels.length > 0 ? `Reco: ${recommendedLabel} (Missed), Hit: ${otherHitLabels.join(' & ')}` : `Reco: ${recommendedLabel} (Missed)`;
                    stateBadgeClass = otherHitLabels.length > 0 ? 'bg-red-500' : recommendedColorClass;
                }
            } else {
                stateBadgeContent = item.status === 'success' ? 'Success (No Reco)' : 'Failed (No Reco)';
                stateBadgeClass = item.status === 'success' ? 'bg-green-600' : 'bg-red-500';
            }
            const showFailIcon = (item.recommendedGroupId && !item.hitTypes.includes(item.recommendedGroupId)) || item.status === 'fail';
            const showSuccessIcon = item.status === 'success' && item.recommendedGroupId && item.hitTypes.includes(item.recommendedGroupId);
            let aiDetailsHtml = '';
            if (item.recommendedGroupId && item.recommendationDetails) {
                const d = item.recommendationDetails;
                aiDetailsHtml = `<div class="ai-details-toggle" data-target="ai-details-${item.id}">Show Details</div><div id="ai-details-${item.id}" class="ai-details-section"><ul>${d.primaryDrivingFactor?`<li><strong>Reason: ${d.primaryDrivingFactor}</strong> (Influence: ${d.adaptiveInfluenceUsed?.toFixed(2)||'1.00'})</li>`:''}<li>Base Score: ${d.baseScore.toFixed(2)}</li>${d.confluenceBonus?`<li>Confluence Bonus: ${d.confluenceBonus.toFixed(2)}x</li>`:''}<li>Hit Rate: ${d.hitRate.toFixed(2)}%</li><li>Avg Trend: ${d.avgTrend.toFixed(1)}</li><li>Proximity: ${d.predictiveDistance!==Infinity?d.predictiveDistance:'N/A'} (Boost: ${d.proximityBoostApplied?'Yes':'No'})</li><li>Neighbour Weighting: ${d.weightedZoneBoostApplied?'Yes':'No'}</li><li>Pattern Boost: ${d.patternBoostApplied?`Yes (${d.patternBoostMultiplier.toFixed(2)}x)`:'No'}</li><li>AI Probability: ${d.mlProbability!==null?(d.mlProbability*100).toFixed(1)+'%':'N/A'} (Boost: ${d.mlBoostApplied?'Yes':'No'})</li><li>AI Low Pocket Boost: ${d.aiLowPocketBoostApplied?'Yes':'No'}</li><li>Final Score: ${d.finalScore.toFixed(2)}</li></ul></div>`;
            }
            li.innerHTML = `${stateBadgeContent?`<div class="state-badge ${stateBadgeClass}">${stateBadgeContent}</div>`:''}<p>${item.num2} - ${item.num1} = <strong class="text-lg">${item.difference}</strong></p><div class="flex items-center space-x-2"><div class="status-box fail-box" style="display:${showFailIcon?'flex':'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg></div><div class="status-box success-box" style="display:${showSuccessIcon?'flex':'none'};"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg></div><button class="delete-btn" data-id="${item.id}" aria-label="Delete item"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m-1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button></div>${aiDetailsHtml}`;
            historyList.appendChild(li);
        });
        document.querySelectorAll('.ai-details-toggle').forEach(toggle => {
            toggle.onclick = () => {
                const target = document.getElementById(toggle.dataset.target);
                if (target) target.classList.toggle('open');
            };
        });
    }

    function renderStrategyWeights() {
        const container = document.getElementById('strategyWeightsDisplay');
        if (!container) return;
        container.innerHTML = '';
        for (const key in strategyStates) {
            const s = strategyStates[key];
            const percent = ((s.weight - STRATEGY_CONFIG.minWeight) / (STRATEGY_CONFIG.maxWeight - STRATEGY_CONFIG.minWeight)) * 100;
            const color = s.weight > 1.0 ? 'bg-green-500' : s.weight < 1.0 ? 'bg-red-500' : 'bg-blue-500';
            container.innerHTML += `<div><div class="flex justify-between items-center mb-1"><span class="font-medium text-sm text-gray-700">${s.name}</span><span class="font-semibold text-sm text-gray-600">${s.weight.toFixed(2)}x</span></div><div class="w-full bg-gray-200 rounded-full h-2.5"><div class="${color} h-2.5 rounded-full" style="width: ${Math.max(0,Math.min(100,percent))}%"></div></div></div>`;
        }
    }

    function updateStrategyWeights(item) {
        if (!item || item.status === 'pending' || !item.recommendedGroupId) return;
        const success = item.hitTypes.includes(item.recommendedGroupId);
        if (useWeightedZone) strategyStates.weightedZone.weight = success ? Math.min(STRATEGY_CONFIG.maxWeight, strategyStates.weightedZone.weight + STRATEGY_CONFIG.learningRate_success) : Math.max(STRATEGY_CONFIG.minWeight, strategyStates.weightedZone.weight - STRATEGY_CONFIG.learningRate_failure);
        if (useProximityBoost) strategyStates.proximityBoost.weight = success ? Math.min(STRATEGY_CONFIG.maxWeight, strategyStates.proximityBoost.weight + STRATEGY_CONFIG.learningRate_success) : Math.max(STRATEGY_CONFIG.minWeight, strategyStates.proximityBoost.weight - STRATEGY_CONFIG.learningRate_failure);
        renderStrategyWeights();
    }

    function updatePatternMemory() {
        const successfulSpins = history.filter(i => i.status === 'success' && i.hitTypes.length > 0).sort((a,b) => a.id - b.id);
        if (successfulSpins.length < 2) return;
        const [prev, last] = successfulSpins.slice(-2);
        if (prev.hitTypes.length === 1 && last.hitTypes.length === 1 && prev.winningNumber !== null) {
            const [triggerType, triggerNum, resultType] = [prev.hitTypes[0], prev.winningNumber, last.hitTypes[0]];
            const typeKey = `trigger-type-${triggerType}`, numKey = `trigger-num-${triggerNum}`;
            if (!patternMemory[typeKey]) patternMemory[typeKey] = {};
            if (!patternMemory[typeKey][resultType]) patternMemory[typeKey][resultType] = { attempts: 0, successes: 0 };
            patternMemory[typeKey][resultType].attempts++; patternMemory[typeKey][resultType].successes++;
            if (!patternMemory[numKey]) patternMemory[numKey] = {};
            if (!patternMemory[numKey][resultType]) patternMemory[numKey][resultType] = { attempts: 0, successes: 0 };
            patternMemory[numKey][resultType].attempts++; patternMemory[numKey][resultType].successes++;
        }
        if (successfulSpins.length < 3) return;
        const [sA, sB, sC] = successfulSpins.slice(-3);
        if (sA.hitTypes.length === 1 && sB.hitTypes.length === 1 && sC.hitTypes.length === 1) {
            const [tA, tB, tC] = [sA.hitTypes[0], sB.hitTypes[0], sC.hitTypes[0]];
            if (tA !== tB) {
                const pKey = `oscillation-${tA}-${tB}`;
                if (!patternMemory[pKey]) patternMemory[pKey] = { attempts: 0, successes: 0 };
                patternMemory[pKey].attempts++;
                if (tA === tC) patternMemory[pKey].successes++;
            }
        }
    }

    function evaluateCalculationStatus(item, winningNum) {
        item.hitTypes = []; item.typeSuccessStatus = {}; let anyHit = false;
        const activeTypes = getActivePredictionTypes();
        const allTypes = getFullPredictionTypes();
        activeTypes.forEach(type => {
            const def = allTypes.find(t => t.id === type.id);
            if (!def) return;
            const baseNum = def.calculateBase(item.num1, item.num2);
            if (baseNum < 0 || baseNum > 36) return;
            const terminals = terminalMapping[baseNum] || [];
            const hitZone = getHitZone(baseNum, terminals, winningNum);
            if (hitZone.includes(winningNum)) {
                item.hitTypes.push(type.id); item.typeSuccessStatus[type.id] = true; anyHit = true;
            } else { item.typeSuccessStatus[type.id] = false; }
        });
        item.status = anyHit ? 'success' : 'fail';
        item.boardState = anyHit ? item.hitTypes.join(' & ') : 'none';
    }

    function labelHistoryFailures(sortedHistory) {
        if (sortedHistory.length < 3) return;
        for (let i = 2; i < sortedHistory.length; i++) {
            const current = sortedHistory[i];
            if (current.status === 'success') { current.failureMode = 'none'; continue; }
            current.failureMode = 'normalLoss';
            const prev = sortedHistory[i-1], prevPrev = sortedHistory[i-2];
            if (prev.winningNumber !== null && current.winningNumber !== null && calculatePocketDistance(current.winningNumber, prev.winningNumber) > 9) {
                current.failureMode = 'sectionShift'; continue;
            }
            if (prev.status === 'success' && prevPrev.status === 'success') {
                for (const hit of new Set(prev.hitTypes)) {
                    if (new Set(prevPrev.hitTypes).has(hit) && !current.typeSuccessStatus[hit]) {
                        current.failureMode = 'streakBreak'; break;
                    }
                }
            }
        }
    }

    async function handleConfirmWinningNumber(calcId) {
        const winNum = parseInt(document.getElementById('winningNumber').value, 10);
        if (isNaN(winNum) || winNum < 0 || winNum > 36) return;
        const item = history.find(i => i.id === calcId);
        if (!item) return;
        evaluateCalculationStatus(item, winNum);
        item.winningNumber = winNum;
        if (!confirmedWinsLog.includes(winNum)) confirmedWinsLog.push(winNum);
        updateStrategyWeights(item); updatePatternMemory();
        if (item.status === 'success') {
            let minPocketDist = Infinity;
            const allTypes = getFullPredictionTypes();
            item.hitTypes.forEach(typeId => {
                const type = allTypes.find(t => t.id === typeId); if (!type) return;
                const baseNum = type.calculateBase(item.num1, item.num2); if (baseNum < 0 || baseNum > 36) return;
                const hitZone = getHitZone(baseNum, terminalMapping[baseNum] || [], winNum);
                hitZone.forEach(zoneNum => minPocketDist = Math.min(minPocketDist, calculatePocketDistance(zoneNum, winNum)));
            });
            item.pocketDistance = minPocketDist === Infinity ? null : minPocketDist;
        } else item.pocketDistance = null;
        if (item.recommendedGroupId && item.winningNumber !== null) {
            const recoDef = getFullPredictionTypes().find(t => t.id === item.recommendedGroupId);
            if (recoDef) {
                const baseNum = recoDef.calculateBase(item.num1, item.num2);
                if (baseNum >= 0 && baseNum <= 36) {
                    let minRecoDist = Infinity;
                    const hitZone = getHitZone(baseNum, terminalMapping[baseNum] || [], item.winningNumber);
                    hitZone.forEach(zoneNum => minRecoDist = Math.min(minRecoDist, calculatePocketDistance(zoneNum, item.winningNumber)));
                    item.recommendedGroupPocketDistance = minRecoDist === Infinity ? null : minRecoDist;
                }
            }
        }
        if (item.recommendedGroupId && item.recommendationDetails?.primaryDrivingFactor) {
            const factor = item.recommendationDetails.primaryDrivingFactor;
            if (adaptiveFactorInfluences[factor] === undefined) adaptiveFactorInfluences[factor] = 1.0;
            const hit = item.hitTypes.includes(item.recommendedGroupId);
            if (hit) adaptiveFactorInfluences[factor] = Math.min(ADAPTIVE_LEARNING_RATES.MAX_INFLUENCE, adaptiveFactorInfluences[factor] + ADAPTIVE_LEARNING_RATES.SUCCESS);
            else adaptiveFactorInfluences[factor] = Math.max(ADAPTIVE_LEARNING_RATES.MIN_INFLUENCE, adaptiveFactorInfluences[factor] - ADAPTIVE_LEARNING_RATES.FAILURE);
        }
        history.forEach((h, i) => {
            const stats = calculateTrendStats(history.slice(0, i+1));
            let maxStreak = 0;
            if (h.status === 'success') h.hitTypes.forEach(tId => maxStreak = Math.max(maxStreak, stats.currentStreaks[tId]));
            h.confirmedStreak = maxStreak;
        });
        labelHistoryFailures(history.slice().sort((a,b) => a.id - b.id));
        runAllAnalyses(); renderHistory();
        if (history.filter(i => i.status === 'success').length >= TRAINING_MIN_HISTORY) {
            isAiReady = false;
            document.getElementById('aiModelStatus').textContent = 'AI Model: Training...';
            aiWorker.postMessage({ type: 'train', payload: { history: history, historicalStreakData: calculateTrendStats().streakData } });
        }
        if (item) {
            document.getElementById('number1').value = item.num2;
            document.getElementById('number2').value = winNum;
            setTimeout(() => handleCalculation(item.num2, winNum), 100);
        }
        saveState();
    }

    async function getPredictionProbabilitiesFromWorker() {
        if (DEBUG_MODE) console.log('Main: Requesting prediction from worker.');
        const trendStats = calculateTrendStats();
        return new Promise(resolve => {
            const handler = e => { if (e.data.type === 'predictionResult') { aiWorker.removeEventListener('message', handler); resolve(e.data.probabilities || {}); } };
            aiWorker.addEventListener('message', handler);
            if (history.filter(i=>i.status==='success').length < AI_SEQUENCE_LENGTH) { resolve({}); return; }
            aiWorker.postMessage({ type: 'predict', payload: { history } });
        });
    }

    async function displayCalculationResult(diff, calcId) {
        if (DEBUG_MODE) console.log('Displaying calculation result...');
        const num1 = parseInt(document.getElementById('number1').value, 10), num2 = parseInt(document.getElementById('number2').value, 10);
        const trendStats = calculateTrendStats(), boardStats = getBoardStateStats(), neighbourScores = runNeighbourAnalysis(false);
        const predictionData = isAiReady ? await getPredictionProbabilitiesFromWorker() : null;
        const reco = getRecommendation(trendStats, boardStats, neighbourScores, diff, num1, num2, false, predictionData, adaptiveFactorInfluences);
        const lastWin = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length - 1] : null;
        let groupInfoHtml = '';
        const activeTypes = getActivePredictionTypes(), allTypes = getFullPredictionTypes();
        activeTypes.forEach(type => {
            if (isNaN(num1) || isNaN(num2)) return;
            const def = allTypes.find(t => t.id === type.id); if (!def) return;
            const baseNum = def.calculateBase(num1, num2); if (baseNum < 0 || baseNum > 36) return;
            const terminals = terminalMapping[baseNum] || [], avgTrend = parseFloat(trendStats.averages?.[type.id])||0, hitRate = boardStats?.[type.id]?.total > 0 ? `${(boardStats?.[type.id]?.success / boardStats?.[type.id]?.total * 100).toFixed(2)}%` : '0.00%', currentStreak = trendStats.currentStreaks?.[type.id]??0;
            const mlProb = (predictionData?.groups?.[type.id] ?? 0) * 100;
            groupInfoHtml += `<p><strong style="color:${type.textColor};">${type.displayLabel} (${baseNum}):</strong> ${terminals.join(', ')||'None'} <span class="text-xs text-gray-500">(Trend: ${avgTrend}, Rate: ${hitRate}, AI: ${mlProb.toFixed(1)}%)</span></p>`;
        });
        const failureHtml = isAiReady && predictionData?.failures ? `<div class="mt-4 p-3 bg-yellow-100 border border-yellow-300 rounded-lg text-center text-sm"><strong class="text-yellow-800">AI Risk:</strong> High chance of ${Object.entries(predictionData.failures).filter(([m,_])=>m!=='none'&&m!=='normalLoss').sort((a,b)=>b[1]-a[1])[0]?.[0] || 'N/A'}.</div>` : '';
        const patternHtml = reco.patternInfo ? `<div class="pattern-alert">${reco.patternInfo}</div>` : '';
        document.getElementById('resultDisplay').innerHTML = `<div class="result-display space-y-4">${patternHtml}<h3 class="text-center font-bold text-lg">Calculation Result: ${diff}</h3><div class="text-sm space-y-2">${groupInfoHtml}</div><div class="text-center pt-2 font-semibold">${reco.html}</div>${failureHtml}<div class="flex items-center space-x-2 pt-2"><input type="number" id="winningNumber" placeholder="Winning #" class="form-input flex-grow"><button id="confirmWinBtn" class="btn btn-primary px-4">Confirm</button></div></div>`;
        document.getElementById('resultDisplay').classList.remove('hidden');
        document.getElementById('confirmWinBtn').addEventListener('click', () => handleConfirmWinningNumber(calcId));
        document.getElementById('winningNumber').addEventListener('keydown', e => { if (e.key==='Enter') handleConfirmWinningNumber(calcId); });
        drawRouletteWheel(diff, lastWin);
    }

    async function handleCalculation() {
        const n1 = parseInt(document.getElementById('number1').value, 10);
        const n2 = parseInt(document.getElementById('number2').value, 10);
        if (isNaN(n1) || isNaN(n2)) return;
        const calcId = Date.now();
        const difference = Math.abs(n2 - n1);
        const reco = getRecommendation(calculateTrendStats(), getBoardStateStats(), runNeighbourAnalysis(false), difference, n1, n2, false, null, adaptiveFactorInfluences);
        const newItem = { id: calcId, num1: n1, num2: n2, difference, status: 'pending', hitTypes: [], typeSuccessStatus: {}, recommendedGroupId: reco.bestCandidate?.type.id || null, recommendationDetails: reco.bestCandidate?.details || null };
        history.push(newItem);
        await displayCalculationResult(difference, calcId);
        renderHistory(); saveState();
    }

    function calculateTrendStats(currentHistory = history, activeTypes = getActivePredictionTypes()) {
        const sortedHistory = [...currentHistory].sort((a, b) => a.id - b.id);
        const streakData = {}, currentStreaks = {}, totalOccurrences = {}, successfulOccurrences = {};
        let lastSuccessState = [];
        activeTypes.forEach(type => { streakData[type.id] = []; currentStreaks[type.id] = 0; totalOccurrences[type.id] = 0; successfulOccurrences[type.id] = 0; });
        sortedHistory.forEach((item, i) => {
            if (item.status === 'pending') return;
            const weight = Math.pow(STRATEGY_CONFIG.decayFactor, sortedHistory.length - 1 - i);
            activeTypes.forEach(type => {
                const def = getFullPredictionTypes().find(t => t.id === type.id); if (!def) return;
                const baseNum = def.calculateBase(item.num1, item.num2);
                if (baseNum >= 0 && baseNum <= 36) totalOccurrences[type.id] += weight;
                if (item.typeSuccessStatus && item.typeSuccessStatus[type.id]) { currentStreaks[type.id]++; successfulOccurrences[type.id] += weight; }
                else { if (currentStreaks[type.id] > 0) streakData[type.id].push(currentStreaks[type.id]); currentStreaks[type.id] = 0; }
            });
            if (item.status === 'success') lastSuccessState = item.hitTypes;
        });
        const averages = {};
        activeTypes.forEach(type => {
            const all = [...streakData[type.id]]; if (currentStreaks[type.id] > 0) all.push(currentStreaks[type.id]);
            averages[type.id] = (all.length > 0) ? (all.reduce((a, b) => a + b, 0) / all.length).toFixed(1) : '0.0';
        });
        return { averages, currentStreaks, lastSuccessState, streakData }; 
    }

    function getBoardStateStats(simulatedHistory = history) {
        const stats = {};
        const activeTypes = getActivePredictionTypes();
        activeTypes.forEach(type => stats[type.id] = { success: 0, total: 0 });
        simulatedHistory.forEach((item, i) => {
            const weight = Math.pow(STRATEGY_CONFIG.decayFactor, simulatedHistory.length - 1 - i);
            activeTypes.forEach(type => {
                const def = getFullPredictionTypes().find(t => t.id === type.id); if (!def) return;
                const baseNum = def.calculateBase(item.num1, item.num2);
                if (baseNum >= 0 && baseNum <= 36) stats[type.id].total += weight;
            });
            if (item.status === 'success') item.hitTypes.forEach(typeId => { if (stats[typeId]) stats[typeId].success += weight; });
        });
        return stats;
    }
    
    function getRecommendation(trendStats, boardStats, neighbourScores, diff, inputNum1, inputNum2, isForWeightUpdate = false, aiPredictionData = null, currentAdaptiveInfluences = adaptiveFactorInfluences) {
        let candidates = [];
        const activeTypes = getActivePredictionTypes();
        const allTypes = getFullPredictionTypes();
        activeTypes.forEach(type => {
            const def = allTypes.find(t => t.id === type.id); if (!def) return;
            const baseNum = def.calculateBase(inputNum1, inputNum2); if (baseNum < 0 || baseNum > 36) return;
            const hitRate = (boardStats[type.id]?.total > 0) ? (boardStats[type.id].success / boardStats[type.id].total) : 0;
            const avgTrend = parseFloat(trendStats.averages[type.id]) || 0;
            let score = hitRate * 100;
            let details = { type: type, baseScore: score, hitRate: hitRate*100, avgTrend: avgTrend, predictiveDistance: Infinity };
            if (useProximityBoost) {
                const lastWin = confirmedWinsLog.length > 0 ? confirmedWinsLog[confirmedWinsLog.length-1] : null;
                if(lastWin !== null) {
                    const hitZone = getHitZone(baseNum, terminalMapping[baseNum]||[], lastWin);
                    let minDist = Infinity;
                    hitZone.forEach(zoneNum => minDist = Math.min(minDist, calculatePocketDistance(zoneNum, lastWin)));
                    details.predictiveDistance = minDist;
                    if(minDist < 2) { score += 15 * strategyStates.proximityBoost.weight; details.proximityBoostApplied = true; }
                }
            }
            if (useWeightedZone) {
                const hitZone = getHitZone(baseNum, terminalMapping[baseNum]||[], null);
                let zoneScore = 0;
                hitZone.forEach(num => zoneScore += (neighbourScores[num]?.success || 0));
                score += (zoneScore / hitZone.length) * 10 * strategyStates.weightedZone.weight;
                details.weightedZoneBoostApplied = true;
            }
            if (aiPredictionData?.groups?.[type.id] !== undefined) {
                const mlProb = aiPredictionData.groups[type.id];
                details.mlProbability = mlProb;
                if (mlProb > 0.6) { score += (mlProb - 0.6) * 100; details.mlBoostApplied = true; }
                const hitZone = getHitZone(baseNum, terminalMapping[baseNum]||[], null);
                let minPocketDist = Infinity;
                if(confirmedWinsLog.length > 0) hitZone.forEach(zoneNum => minPocketDist = Math.min(minPocketDist, calculatePocketDistance(zoneNum, confirmedWinsLog[confirmedWinsLog.length-1])));
                if(mlProb > 0.5 && minPocketDist < 4) { score += 20; details.aiLowPocketBoostApplied = true; }
            }
            const patternKeyType = `trigger-type-${trendStats.lastSuccessState[0]}`;
            const patternKeyNum = `trigger-num-${confirmedWinsLog[confirmedWinsLog.length-1]}`;
            if(patternMemory[patternKeyType] && patternMemory[patternKeyType][type.id]) {
                const pat = patternMemory[patternKeyType][type.id];
                if(pat.attempts >= STRATEGY_CONFIG.triggerMinAttempts && (pat.successes/pat.attempts*100) >= STRATEGY_CONFIG.triggerSuccessThreshold) {
                    score *= 1.5; details.patternBoostApplied = true; details.patternBoostMultiplier = 1.5;
                }
            }
            details.finalScore = score;
            candidates.push(details);
        });
        if (candidates.length === 0) return { html: 'Waiting for input...', bestCandidate: null };
        candidates.sort((a,b) => b.finalScore - a.finalScore);
        let bestCandidate = candidates[0];
        let recoHtml = `Play <strong style="color:${bestCandidate.type.textColor};">${bestCandidate.type.displayLabel}</strong>`;
        if (useLessStrict && (bestCandidate.hitRate > 60 || trendStats.currentStreaks[bestCandidate.type.id] >= 3)) {
            recoHtml += ' <span class="text-indigo-600 font-bold">(High Confidence)</span>';
            bestCandidate.primaryDrivingFactor = bestCandidate.hitRate > 60 ? 'High Hit Rate' : 'Streak';
        } else if (useTrendConfirmation && trendStats.lastSuccessState.length > 0 && !trendStats.lastSuccessState.includes(bestCandidate.type.id)) {
            recoHtml = `Wait for Trend Confirmation`;
        }
        return { html: recoHtml, bestCandidate: bestCandidate, details: bestCandidate };
    }

    function runBoardStateAnalysis(simulatedHistory = history) {
        const stats = getBoardStateStats(simulatedHistory);
        const container = document.getElementById('boardStateAnalysis');
        container.innerHTML = '';
        const allTypes = getFullPredictionTypes();
        Object.entries(stats).forEach(([typeId, {success, total}]) => {
            const type = allTypes.find(t => t.id === typeId);
            if (!type) return;
            const hitRate = total > 0 ? (success / total * 100) : 0;
            container.innerHTML += `<div class="text-sm"><strong style="color:${type.textColor};">${type.displayLabel}:</strong> ${hitRate.toFixed(2)}% Hit Rate</div>`;
        });
    }

    function runNeighbourAnalysis(render = true, simulatedHistory = history) {
        const analysis = {};
        for(let i=0; i<=36; i++) analysis[i] = { success: 0 };
        simulatedHistory.forEach((item, i) => {
            if(item.status !== 'success') return;
            const weight = Math.pow(STRATEGY_CONFIG.decayFactor, simulatedHistory.length - 1 - i);
            const allTypes = getFullPredictionTypes();
            item.hitTypes.forEach(typeId => {
                const type = allTypes.find(t => t.id === typeId); if (!type) return;
                const baseNum = type.calculateBase(item.num1, item.num2); if(baseNum < 0 || baseNum > 36) return;
                const terminals = terminalMapping[baseNum] || [];
                const points = {};
                getNeighbours(baseNum, (terminals.length === 1) ? 3 : (terminals.length >= 2) ? 1 : 0).forEach(n => points[n] = (points[n]||0) + 1);
                let tnc = (terminals.length === 1 || terminals.length === 2) ? 3 : (terminals.length > 2) ? 1 : 0;
                if(useDynamicTerminalNeighbourCount && item.winningNumber !== null && (baseNum === item.winningNumber || terminals.includes(item.winningNumber))) tnc=0;
                if(tnc > 0) terminals.forEach(t => getNeighbours(t, tnc).forEach(n => points[n] = (points[n]||0) + 1));
                for(const num in points) if(analysis[num]) analysis[num].success += points[num] * weight;
            });
        });
        if(render) {
            const list = document.getElementById('analysisList');
            list.innerHTML = '';
            Object.entries(analysis).map(([num,s])=>({num:parseInt(num),score:s.success})).sort((a,b)=>b.score-a.score).forEach(({num,score})=>{
                list.innerHTML += `<li class="p-2 rounded-md ${score>0?'bg-green-50':''}"><div class="grid grid-cols-2 items-center"><div class="font-bold text-lg text-center text-indigo-600">${num}</div><div class="font-semibold text-center ${score > 0 ? 'text-green-700' : 'text-gray-600'}">Score: ${score.toFixed(2)}</div></div></li>`;
            });
        }
        return analysis;
    }

    function runAllAnalyses() {
        runBoardStateAnalysis();
        runNeighbourAnalysis();
        renderStrategyWeights();
    }

    function createSlider(containerId, label, paramObj, paramName, min, max, step) {
        const container = document.getElementById(containerId);
        const id = `${paramName}Slider`;
        const group = document.createElement('div');
        group.className = 'slider-group';
        group.innerHTML = `<label for="${id}">${label}</label><input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}"><input type="number" id="${id}Input" min="${min}" max="${max}" step="${step}" value="${paramObj[paramName]}" class="form-input text-sm">`;
        container.appendChild(group);
        const slider = document.getElementById(id), numInput = document.getElementById(`${id}Input`);
        const update = (src, tgt) => {
            let val = parseFloat(src.value);
            if(isNaN(val)) val = DEFAULT_PARAMETERS[paramObj === STRATEGY_CONFIG ? 'STRATEGY_CONFIG' : 'ADAPTIVE_LEARNING_RATES'][paramName];
            val = Math.max(min, Math.min(max, val));
            tgt.value = val; src.value = val;
            paramObj[paramName] = val;
            saveState();
            document.getElementById('parameterStatusMessage').textContent = 'Parameter changed. Re-analyzing...';
            handleStrategyChange();
        };
        slider.addEventListener('input', () => update(slider, numInput));
        numInput.addEventListener('change', () => update(numInput, slider));
    }

    function initializeAdvancedSettingsUI() {
        ['strategyLearningRatesSliders', 'patternThresholdsSliders', 'adaptiveInfluenceSliders'].forEach(id => document.getElementById(id).innerHTML = '');
        createSlider('strategyLearningRatesSliders', 'Success Learn Rate', STRATEGY_CONFIG, 'learningRate_success', 0.01, 1.0, 0.01);
        createSlider('strategyLearningRatesSliders', 'Failure Learn Rate', STRATEGY_CONFIG, 'learningRate_failure', 0.01, 0.5, 0.01);
        createSlider('strategyLearningRatesSliders', 'Max Weight', STRATEGY_CONFIG, 'maxWeight', 1.0, 10.0, 0.1);
        createSlider('strategyLearningRatesSliders', 'Min Weight', STRATEGY_CONFIG, 'minWeight', 0.0, 1.0, 0.01);
        createSlider('strategyLearningRatesSliders', 'Decay Factor', STRATEGY_CONFIG, 'decayFactor', 0.7, 0.99, 0.01);
        createSlider('patternThresholdsSliders', 'Pattern Min Attempts', STRATEGY_CONFIG, 'patternMinAttempts', 1, 20, 1);
        createSlider('patternThresholdsSliders', 'Pattern Success %', STRATEGY_CONFIG, 'patternSuccessThreshold', 50, 100, 1);
        createSlider('patternThresholdsSliders', 'Trigger Min Attempts', STRATEGY_CONFIG, 'triggerMinAttempts', 1, 20, 1);
        createSlider('patternThresholdsSliders', 'Trigger Success %', STRATEGY_CONFIG, 'triggerSuccessThreshold', 50, 100, 1);
        createSlider('adaptiveInfluenceSliders', 'Adaptive Success Rate', ADAPTIVE_LEARNING_RATES, 'SUCCESS', 0.01, 0.5, 0.01);
        createSlider('adaptiveInfluenceSliders', 'Adaptive Failure Rate', ADAPTIVE_LEARNING_RATES, 'FAILURE', 0.01, 0.5, 0.01);
        createSlider('adaptiveInfluenceSliders', 'Min Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MIN_INFLUENCE', 0.0, 1.0, 0.01);
        createSlider('adaptiveInfluenceSliders', 'Max Adaptive Influence', ADAPTIVE_LEARNING_RATES, 'MAX_INFLUENCE', 1.0, 5.0, 0.1);
    }

    function resetAllParameters() {
        Object.assign(STRATEGY_CONFIG, DEFAULT_PARAMETERS.STRATEGY_CONFIG);
        Object.assign(ADAPTIVE_LEARNING_RATES, DEFAULT_PARAMETERS.ADAPTIVE_LEARNING_RATES);
        Object.assign(window, DEFAULT_PARAMETERS.TOGGLES);
        updateAllTogglesUI(); initializeAdvancedSettingsUI(); saveState();
        document.getElementById('parameterStatusMessage').textContent = 'Parameters reset.';
        handleStrategyChange();
    }

    function saveParametersToFile() {
        const data = JSON.stringify({ STRATEGY_CONFIG, ADAPTIVE_LEARNING_RATES, TOGGLES: DEFAULT_PARAMETERS.TOGGLES }, null, 2);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([data], {type:'application/json'}));
        a.download = 'roulette_parameters.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }

    async function loadParametersFromFile(event) {
        const file = event.target.files[0];
        if(!file) return;
        try {
            const params = JSON.parse(await file.text());
            if(params.STRATEGY_CONFIG) Object.assign(STRATEGY_CONFIG, params.STRATEGY_CONFIG);
            if(params.ADAPTIVE_LEARNING_RATES) Object.assign(ADAPTIVE_LEARNING_RATES, params.ADAPTIVE_LEARNING_RATES);
            if(params.TOGGLES) Object.assign(window, params.TOGGLES);
            updateAllTogglesUI(); initializeAdvancedSettingsUI(); saveState();
            document.getElementById('parameterStatusMessage').textContent = 'Parameters loaded.';
            handleStrategyChange();
        } catch (e) {
            document.getElementById('parameterStatusMessage').textContent = 'Error loading file.';
        }
    }

    function toggleParameterSliders(enable) {
        document.querySelectorAll('#advancedSettingsContent input, #advancedSettingsContent button, #presetStrategyGuideContent button').forEach(el => el.disabled = !enable);
        document.getElementById('loadParametersLabel').classList.toggle('btn-disabled', !enable);
    }

    // ===============================================
    // DOMContentLoaded - APPLICATION STARTUP
    // ===============================================
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const clonablePredictionTypes = getFullPredictionTypes().map(({id, label, displayLabel, colorClass, textColor}) => ({id, label, displayLabel, colorClass, textColor}));
            const dom = {
                number1: document.getElementById('number1'), number2: document.getElementById('number2'), resultDisplay: document.getElementById('resultDisplay'),
                historyList: document.getElementById('historyList'), aiModelStatus: document.getElementById('aiModelStatus'),
                // ... Add other necessary DOM elements here for brevity
            };
            
            aiWorker = new Worker('aiWorker.js');
            optimizationWorker = new Worker('optimizationWorker.js');

            optimizationWorker.onmessage = e => {
                const {type, payload} = e.data;
                const optStatus = document.getElementById('optimizationStatus'), optResult = document.getElementById('optimizationResult');
                switch(type) {
                    case 'progress':
                        optStatus.innerHTML = `Evolving... Gen: <strong>${payload.generation}/${payload.maxGenerations}</strong><br>Variations: <strong>${payload.processedCount}</strong><br>Best W/L: <strong>${payload.bestFitness}</strong>`;
                        bestFoundParams = payload.bestIndividual;
                        break;
                    case 'complete':
                        optStatus.textContent = 'Optimization finished!'; optResult.classList.remove('hidden');
                        document.getElementById('bestFitnessResult').textContent = payload.bestFitness;
                        document.getElementById('bestParamsResult').textContent = JSON.stringify(payload.bestIndividual, null, 2);
                        bestFoundParams = payload.bestIndividual;
                        toggleParameterSliders(true);
                        document.getElementById('startOptimizationButton').disabled = false; document.getElementById('stopOptimizationButton').disabled = true;
                        break;
                    case 'stopped':
                        optStatus.textContent = 'Optimization stopped.'; toggleParameterSliders(true);
                        document.getElementById('startOptimizationButton').disabled = false; document.getElementById('stopOptimizationButton').disabled = true;
                        break;
                }
            };
            aiWorker.onmessage = e => {
                const {type, message, payload} = e.data;
                if(type === 'status') { document.getElementById('aiModelStatus').textContent = message; isAiReady = message.includes('Ready!'); }
                else if(type === 'saveScaler') localStorage.setItem('roulette-ml-scaler', payload);
            };

            document.addEventListener('click', e => {
                const targetId = e.target.id || e.target.closest('button')?.id;
                switch(targetId) {
                    case 'calculateButton': handleCalculation(); break;
                    case 'clearInputsButton': document.getElementById('number1').value = ''; document.getElementById('number2').value = ''; document.getElementById('resultDisplay').classList.add('hidden'); drawRouletteWheel(); break;
                    case 'swapButton': const n1 = document.getElementById('number1'); const n2 = document.getElementById('number2'); const temp = n1.value; n1.value = n2.value; n2.value = temp; break;
                    case 'clearHistoryButton': handleClearHistory(); break;
                    case 'analyzeHistoricalDataButton': handleHistoricalAnalysis(); break;
                    case 'recalculateAnalysisButton': runAllAnalyses(); break;
                    case 'analyzeVideoButton': startVideoAnalysis(); break;
                    case 'clearVideoButton': clearVideoState(); break;
                    case 'setHighestWinRatePreset': handlePresetSelection('highestWinRate'); break;
                    case 'setBalancedSafePreset': handlePresetSelection('balancedSafe'); break;
                    case 'setAggressiveSignalsPreset': handlePresetSelection('aggressiveSignals'); break;
                    case 'resetParametersButton': resetAllParameters(); break;
                    case 'saveParametersButton': saveParametersToFile(); break;
                    case 'startOptimizationButton':
                        if (history.length < 20) { document.getElementById('optimizationStatus').textContent = 'Error: Need at least 20 history items.'; return; }
                        document.getElementById('optimizationStatus').textContent = 'Starting optimization...';
                        document.getElementById('optimizationResult').classList.add('hidden');
                        toggleParameterSliders(false);
                        document.getElementById('startOptimizationButton').disabled = true; document.getElementById('stopOptimizationButton').disabled = false;
                        const helpers = { calculateTrendStats: calculateTrendStats.toString(), getBoardStateStats: getBoardStateStats.toString(), getRecommendation: getRecommendation.toString(), runNeighbourAnalysis: runNeighbourAnalysis.toString(), getHitZone: getHitZone.toString(), getNeighbours: getNeighbours.toString(), calculatePocketDistance: calculatePocketDistance.toString(), allPredictionTypes: clonablePredictionTypes, terminalMapping: terminalMapping, rouletteWheel: rouletteWheel };
                        optimizationWorker.postMessage({ type: 'start', payload: { history, helpers } });
                        break;
                    case 'stopOptimizationButton': optimizationWorker.postMessage({ type: 'stop' }); break;

                    case 'applyBestParamsButton':
                        if (bestFoundParams) {
                            Object.assign(STRATEGY_CONFIG, bestFoundParams);
                            // Need to handle ADAPTIVE_LEARNING_RATES separately if they are also optimized
                            initializeAdvancedSettingsUI(); saveState();
                            document.getElementById('optimizationStatus').textContent = 'Best parameters applied and saved!';
                            handleStrategyChange();
                        }
                        break;
                    default:
                        if(e.target.closest('.delete-btn')) handleHistoryAction(e);
                        break;
                }
            });

            document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
            document.getElementById('videoUpload').addEventListener('change', handleVideoUpload);
            document.getElementById('loadParametersInput').addEventListener('change', loadParametersFromFile);
            [document.getElementById('number1'), document.getElementById('number2')].forEach(input => input.addEventListener('keydown', e => { if (e.key === 'Enter') handleCalculation(); }));
            Object.keys(DEFAULT_PARAMETERS.TOGGLES).forEach(key => {
                const toggleId = key.replace('use', '').charAt(0).toLowerCase() + key.slice(4) + 'Toggle';
                const toggle = document.getElementById(toggleId);

                if (toggle) {
                    toggle.addEventListener('change', e => {
                        window[key] = e.target.checked;
                        saveState();
                        if (key === 'usePocketDistance') renderHistory();
                        else if (key === 'useAdvancedCalculations') { updateActivePredictionTypes(); handleStrategyChange(); }
                        else handleStrategyChange();
                    });
                }
            });

            const savedScaler = localStorage.getItem('roulette-ml-scaler');
            aiWorker.postMessage({ type: 'init', payload: { allPredictionTypes: clonablePredictionTypes, scaler: savedScaler } });

            loadState();
            runAllAnalyses();
            renderHistory();
            drawRouletteWheel();
        } catch (error) {
            if (DEBUG_MODE) console.error('Error during DOMContentLoaded setup:', error);
            document.body.innerHTML = `<div class="card p-8 text-center text-red-600 font-bold text-xl"><p>A critical error occurred during application startup.</p><p>Please check the browser's developer console (F12) for details.</p><p>Error: ${error.message}</p></div>`;
        }
    });
</script>

</body>
</html>